[{"content":"如图：\n","permalink":"https://tiandiyijian.top/posts/goland%E5%92%8Cidea%E4%BD%BF%E7%94%A8cmder/","summary":"如图：","title":"Goland和IDEA使用cmder"},{"content":"1 2  $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系   这两行命令执行过之后会在当前 conda 环境的 bin 目录中生成这两个文件：\n1 2  x86_64-conda-linux-gnu-gcc x86_64-conda-linux-gnu-g++   为了方便使用可以用软链创建两个文件：\n1 2  $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-gcc ~/miniconda3(your conda path)/envs/(env)/bin/gcc $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-g++ ~/miniconda3(your conda path)/envs/(env)/bin/g++   然后重启一下环境应该就生效了。\n参考：如何改变anaconda 的 gcc 版本？ - 徐智明的回答 - 知乎 \n","permalink":"https://tiandiyijian.top/posts/conda%E5%AE%89%E8%A3%85gcc%E5%92%8Cg++/","summary":"1 2 $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系 这两行命令执行过之后会","title":"Conda安装gcc和g++"},{"content":"2.语言机制 2.1变量 Type is everything, type is life!\n类型提供了两个信息：内存大小和它的表示方法。\n如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明它。\n为了完整性（integrity），Go 没有 casting 机制，所以需要显示类型转换。\n2.2结构体 大小 如果要理解成本，必须要理解内存分配。\nCPU 访问内存是以字长（比如 32 位机器是 4 字节）为单位的，为了方便 CPU 访问即提高内存读写效率，结构体需要做内存对齐。\n内存对齐主要遵循下面三个原则：\n 结构体变量的起始地址能够被其最宽的成员大小整除 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节  Go语言中空结构体的大小为0，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的，但是空结构体有一个特例，那就是当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放），所以当struct{}作为结构体成员中最后一个字段时，要填充额外的内存保证安全。\n如果真的很需要做内存优化的话，可以把结构体中的字段按从大到小的顺序排列，但是最好还是按照语义顺序来，因为可读性才是最重要的。\n类型转换 字段完全相同（顺序也要相同）的命名类型之间赋值需要做显示转换，匿名类型可以直接赋值，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // example represents a type with different fields. type example struct { \tflag bool \tcounter int16 \tpi float32 }  type example2 struct { \tflag bool \tcounter int16 \tpi float32 }  func main() {  \t// Declare a variable of an anonymous type and init \t// using a struct literal. \te := struct { \tflag bool \tcounter int16 \tpi float32 \t}{ \tflag: true, \tcounter: 10, \tpi: 3.141592, \t}  \t// Create a value of type example. \tvar ex example \tvar ex2 example2  \t// ex = ex2 // cannot use ex2 (variable of type example2) as type example in assignment \tex = example(ex2)  \t// Assign the value of the unnamed struct type \t// to the named struct type value. \tex = e  \t// Display the values. \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, ex) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, e) }   2.3指针 传值 Go 只有传值，好处是提供了隔离性，局部的改动不会影响全局。坏处是可能影响性能，因为一份数据可能在程序中有多个拷贝，而且如果相同时改变这些拷贝有一定难度。\n共享数据 如果需要共享数据的话就需要传指针了，但是指针也是值，是地址的值而不是引用，取决于不同的操作系统一个指针会占用4字节或者8字节的空间，在传指针的时候会发生一次地址值的拷贝。另外，指针是字面量类型，它是有类型的，因为有了类型编译器才知道一种特定的指针可以做什么操作，Type is life！\n逃逸分析 栈能带来的好处不仅是 isolation 和 immutability 以及减少 side effects，还能在很多情况下带来更好的性能，因为它是自清理的，一个函数返回之后它的栈已经完全没用了，它上层的函数再进行函数调用时可以直接覆盖，不需要垃圾收集器。\n所以，如果要共享一个变量的话，就必须把它分配在堆上，然后返回它的指针即地址值。\n为了更好的可读性，一定要区分开什么时候使用值语义，什么时候使用指针语义。在构造过程中不要使用指针语义，如果需要共享它就在 return 时使用 \u0026amp; 操作符，这样一眼就能看出它是否逃逸到堆中。如果变量的生命从指针开始，那么就失去可读性了，因为它并不能告诉你它在内存中的位置。\n像这样的代码就非常折磨。\n另外，当编译器不知道某个变量的大小（比如切片）时，那么也会在堆上分配它的内存。栈并不是动态的，在编译期就已经确定。\n如果变量太大时，也会把它分配在堆上。\n栈增长 当栈空间（2K）满时，会扩容25%，然后把之前的内容拷贝到新栈上去，这意味这栈里面变量的内存地址是有可能发生改变的。既然栈的地址是可能发生变化的，在 Go 中，栈内存在 goroutine 之间是不能共享的。\n垃圾回收 影响性能的因素（1.3节）\n 网络和磁盘 IO 延迟 内存分配和垃圾回收 访问数据的方式和效率 算法  小堆、回收频率、时间短之间的平衡\n2.4常数 常数只在编译期存在，最少拥有256比特的精度。下面的程序可以通过编译，但是如果要使用 bigger 这个变量就会在编译期报溢出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how constants do have a parallel type system. package main  import \u0026#34;fmt\u0026#34;  const ( \t// Max integer value on 64 bit architecture. \tmaxInt = 9223372036854775807  \t// Much larger value than int64. \tbigger = 9223372036854775808543522345  \t// Will NOT compile \t// biggerInt int64 = 9223372036854775808543522345 )  func main() { \tfmt.Println(\u0026#34;Will Compile\u0026#34;) \t//fmt.Println(maxInt, bigger) }   常数是没有类型的，可以把它的类型理解为另一种东西——种类 kind，编译器会根据上下文做隐式转换（在函数传参的时候非常方便，不用做类型转换直接传一个字面量就行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how to declare constants and their // implementation in Go. package main  func main() {  \t// Constants live within the compiler. \t// They have a parallel type system. \t// Compiler can perform implicit conversions of untyped constants.  \t// Untyped Constants. \tconst ui = 12345 // kind: integer \tconst uf = 3.141592 // kind: floating-point  \t// Typed Constants still use the constant type system but their precision \t// is restricted. \tconst ti int = 12345 // type: int \tconst tf float64 = 3.141592 // type: float64  \t// ./constants.go:XX: constant 1000 overflows uint8 \t// const myUint8 uint8 = 1000  \t// Constant arithmetic supports different kinds. \t// Kind Promotion is used to determine kind in these scenarios.  \t// Variable answer will of type float64. \tvar answer = 3 * 0.333 // KindFloat(3) * KindFloat(0.333)  \t// Constant third will be of kind floating point. \tconst third = 1 / 3.0 // KindFloat(1) / KindFloat(3.0)  \t// Constant zero will be of kind integer. \tconst zero = 1 / 3 // KindInt(1) / KindInt(3)  \t// This is an example of constant arithmetic between typed and \t// untyped constants. Must have like types to perform math. \tconst one int8 = 1 \tconst two = 2 * one // int8(2) * int8(1) }   声明常量时可以使用 iota，它表示行数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how iota works. package main  import \u0026#34;fmt\u0026#34;  func main() {  \tconst ( \tA1 = iota // 0 : Start at 0 \tB1 = iota // 1 : Increment by 1 \tC1 = iota // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;1:\u0026#34;, A1, B1, C1)  \tconst ( \tA2 = iota // 0 : Start at 0 \tB2 // 1 : Increment by 1 \tC2 // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;2:\u0026#34;, A2, B2, C2)  \tconst ( \tA3 = iota + 1 // 1 : Start at 0 + 1 \tB3 // 2 : Increment by 1 \tC3 // 3 : Increment by 1 \t)  \tfmt.Println(\u0026#34;3:\u0026#34;, A3, B3, C3)  \tconst ( \tLdate = 1 \u0026lt;\u0026lt; iota // 1 : Shift 1 to the left 0. 0000 0001 \tLtime // 2 : Shift 1 to the left 1. 0000 0010 \tLmicroseconds // 4 : Shift 1 to the left 2. 0000 0100 \tLlongfile // 8 : Shift 1 to the left 3. 0000 1000 \tLshortfile // 16 : Shift 1 to the left 4. 0001 0000 \tLUTC // 32 : Shift 1 to the left 5. 0010 0000 \t)  \tfmt.Println(\u0026#34;Log:\u0026#34;, Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC) }   ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-%E7%AC%94%E8%AE%B0/","summary":"2.语言机制 2.1变量 Type is everything, type is life! 类型提供了两个信息：内存大小和它的表示方法。 如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明","title":"Ultimate Go Programming 笔记——第二章"},{"content":"添加搜索 添加分类和标签 ","permalink":"https://tiandiyijian.top/posts/hugo%E8%B8%A9%E5%9D%91/","summary":"添加搜索 添加分类和标签","title":"Hugo踩坑"}]