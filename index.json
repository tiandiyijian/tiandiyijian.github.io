[{"content":"6. Error Handling 6.1 Default Error Values 退出程序的两种方式：os.exit() 和 panic()，如果需要跟踪堆栈信息就用后者。\nerror 是接口，是解耦的，这很重要，提供了很大的灵活性，因为 error 分布很广泛，我们希望可以改进和重构错误处理而不在代码库中产生大量的级联变化。\nError() 方法的作用只应该是 log，所以这个方法返回的结果应该是直接能用的而不需要让用户自己去解析，即不能让用户通过解析来获取上下文信息。\n最好用指针语义来实现error接口\n使用快乐路径处理错误情况，不要用 else，太复杂，如果需要的话就用 switch。\n6.2 Error Variables 当函数只返回一个值并且上下文不复杂的时候使用 errorString 类型的全局变量就行。如：\n1 2 3 4 5 6 7  var (  // ErrBadRequest is returned when there are problems with the request.  ErrBadRequest = errors.New(\u0026#34;Bad Request\u0026#34;)   // ErrPageMoved is returned when a 301/302 is returned.  ErrPageMoved = errors.New(\u0026#34;Page Moved\u0026#34;) )   6.3 Type as Context Type as context, applies when we\u0026rsquo;re goona need our own custom error types.\n用 switch 语句判断类型，e 是原值的拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() {  var u user  err := Unmarshal([]byte(`{\u0026#34;name\u0026#34;:\u0026#34;bill\u0026#34;}`), u) // Run with a value and pointer.  if err != nil {  switch e := err.(type) {  case *UnmarshalTypeError:  fmt.Printf(\u0026#34;UnmarshalTypeError: Value[%s] Type[%v]\\n\u0026#34;, e.Value, e.Type)  case *InvalidUnmarshalError:  fmt.Printf(\u0026#34;InvalidUnmarshalError: Type[%v]\\n\u0026#34;, e.Type)  default:  fmt.Println(err)  }  return  }   fmt.Println(\u0026#34;Name:\u0026#34;, u.Name) }   我们希望能在我们能做到的范围内用解耦的状态处理错误，因为从解耦的状态切换到具体的状态，那么任何针对这些具体类型做的关于错误处理的改进都可能引起级联变化。\n但是当需要跨越程序边界移动具体的数据时（两边都需要对具体数据本身进行处理），类型作为上下文是非常强大的。\n怎么能够使用自定义错误类型又不进入具体内容呢？这就是接下来要讨论的行为即上下文的想法。\n6.4 Behavior as Context 自定义错误类型可能不只有状态，也有行为。比如下面这个 net 包中错误类型的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  package example  import (  \u0026#34;bufio\u0026#34;  \u0026#34;fmt\u0026#34;  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;net\u0026#34; )  // client represents a single connection in the room. type client struct {  name string  reader *bufio.Reader }  // TypeAsContext shows how to check multiple types of possible custom error // types that can be returned from the net package. func (c *client) TypeAsContext() {  for {  line, err := c.reader.ReadString(\u0026#39;\\n\u0026#39;)  if err != nil {  switch e := err.(type) {  case *net.OpError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   case *net.AddrError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   case *net.DNSConfigError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   default:  if err == io.EOF {  log.Println(\u0026#34;EOF: Client leaving chat\u0026#34;)  return  }   log.Println(\u0026#34;read-routine\u0026#34;, err)  }  }   fmt.Println(line)  } }  // temporary is declared to test for the existence of the method coming // from the net package. type temporary interface {  Temporary() bool }  // BehaviorAsContext shows how to check for the behavior of an interface // that can be returned from the net package. func (c *client) BehaviorAsContext() {  for {  line, err := c.reader.ReadString(\u0026#39;\\n\u0026#39;)  if err != nil {  switch e := err.(type) {  case temporary:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   default:  if err == io.EOF {  log.Println(\u0026#34;EOF: Client leaving chat\u0026#34;)  return  }   log.Println(\u0026#34;read-routine\u0026#34;, err)  }  }   fmt.Println(line)  } }   用到的三种错误类型都有 Temporary 方法并且都使用这个方法，所以可以自定义一个 temporary 接口。\n当使用自定义错误类型时，一般遵循这个规则：如果自定义错误类型有以下四个方法中的其中一种，那么这个类型最好被定义为具有未导出字段的未导出类型，从而强迫用户不能从一个解耦的状态转换到具体的。这四个方法分别是：Temporary、time out、not found、not authorized。\n6.4 Find the Bug 如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show see if the class can find the bug. package main  import \u0026#34;log\u0026#34;  // customError is just an empty struct. type customError struct{}  // Error implements the error interface. func (c *customError) Error() string { \treturn \u0026#34;Find the bug.\u0026#34; }  // fail returns nil values for both return types. func fail() ([]byte, *customError) { \treturn nil, nil }  func main() { \tvar err error \tif _, err = fail(); err != nil { \tlog.Fatal(\u0026#34;Why did this fail?\u0026#34;) \t}  \tlog.Println(\u0026#34;No Error\u0026#34;) }   Go Playground\n这段代码会报错，理论上来说不应该报错的，因为 fail 返回的 error 是 nil，但是为什么会会报错呢？实际上，接口会存储它所包含变量的类型和值，只有当类型和值都为空时它才为空即等于 nil，在这里 err 的值虽然为空，但是它的类型是 *customError ，所以造成了这种现象。可以参考这段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show see if the class can find the bug. package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; )  // customError is just an empty struct. type customError struct{}  // Error implements the error interface. func (c *customError) Error() string { \treturn \u0026#34;Find the bug.\u0026#34; }  // fail returns nil values for both return types. func fail() ([]byte, *customError) { \treturn nil, nil }  func main() { \tvar err error \tfmt.Printf(\u0026#34;Type of value stored inside the interface: %T\\n\u0026#34;, err)  \tif _, err = fail(); err != nil { \tfmt.Printf(\u0026#34;Type of value stored inside the interface: %T\\n\u0026#34;, err) \t}  \tlog.Println(\u0026#34;No Error\u0026#34;) }   Go Playground\n这段代码的输出是：\n1 2 3  Type of value stored inside the interface: \u0026lt;nil\u0026gt; Type of value stored inside the interface: *main.customError 2009/11/10 23:00:00 No Error   如果使用 struct 自定义错误类型，最好使用指针语义。看下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how the default error type is implemented. package main  import \u0026#34;fmt\u0026#34;  // http://golang.org/pkg/builtin/#error type error interface { \tError() string }  // http://golang.org/src/pkg/errors/errors.go type errorString struct { \ts string }  // http://golang.org/src/pkg/errors/errors.go func (e *errorString) Error() string { \treturn e.s }  // http://golang.org/src/pkg/errors/errors.go // New returns an error that formats as the given text. func New(text string) error { \treturn \u0026amp;errorString{text} }  var bad = New(\u0026#34;Bad Request\u0026#34;)  func main() { \tif err := webCall(); err == bad { \tfmt.Println(err) \treturn \t}  \tfmt.Println(\u0026#34;Life is good\u0026#34;) }  // webCall performs a web operation. func webCall() error { \treturn New(\u0026#34;Bad Request\u0026#34;) }   Go Playground\n它的输出是：Life is good 即 err != bad，但是如果改成使用值语义即把 errorString 的实现改成下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // http://golang.org/src/pkg/errors/errors.go type errorString struct { \ts string }  // http://golang.org/src/pkg/errors/errors.go func (e errorString) Error() string { \treturn e.s }  // http://golang.org/src/pkg/errors/errors.go // New returns an error that formats as the given text. func New(text string) error { \treturn errorString{text} }   那么这段代码就会输出：Bad Request 即 err = bad，因为接口在比较时会比较存储在里面的类型和值，当值和类型都相等的话才相等。如果使用值语义，那么 err 存储的值和类型确实都和 bad 的一样，但是如果使用指针语义的话，那么它们存储的值是指针，而 New 每次返回的 errorString 的地址都不一样所以它们才不会相等。\n6.5 Wrapping Errors 很多 Go 代码都缺乏 log 一致性。\n错误处理和日志记录实际上是同一件事情。\nLog 可能会产生大量的分配，会给堆带来很大的压力。log 很重要，但是我们必须平衡日志中的信号和噪音，因为如果写了日志却从来不会用到，那么就只是在浪费 CPU 周期。所以最好只记录有足够的上下文信息的最少的日志，而且要以同样的方式记录日志而不是随机的。\n如果一段代码要处理错误，它必须决定是否要恢复它，如果不，那么就要关闭程序即调用 panic 或者 os.Exit；如果要恢复，那么它必须把程序恢复到正确的状态并且继续运行。当它返回的时候绝对不会返回另一个 error。\n在调用栈中处理错误的位置越低，恢复的机会就更大。\n如果不处理的话，那么 wrap 这个 error 并返回就可以了。wrap 要做的是添加两种类型的上下文信息，一种是调用栈上下文，一种是用户上下文。\nDave Cheney 的包很符合这种哲学，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how wrapping errors work. package main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/pkg/errors\u0026#34; )  // AppError represents a custom error type. type AppError struct { \tState int }  // Error implements the error interface. func (c *AppError) Error() string { \treturn fmt.Sprintf(\u0026#34;App Error, State: %d\u0026#34;, c.State) }  func main() {  \t// Make the function call and validate the error. \tif err := firstCall(10); err != nil {  \t// Use type as context to determine cause. \tswitch v := errors.Cause(err).(type) { \tcase *AppError:  \t// We got our custom error type. \tfmt.Println(\u0026#34;Custom App Error:\u0026#34;, v.State)  \tdefault:  \t// We did not get any specific error type. \tfmt.Println(\u0026#34;Default Error\u0026#34;) \t}  \t// Display the stack trace for the error. \tfmt.Println(\u0026#34;\\nStack Trace\\n********************************\u0026#34;) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, err) \tfmt.Println(\u0026#34;\\nNo Trace\\n********************************\u0026#34;) \tfmt.Printf(\u0026#34;%v\\n\u0026#34;, err) \t} }  // firstCall makes a call to a second function and wraps any error. func firstCall(i int) error { \tif err := secondCall(i); err != nil { \treturn errors.Wrapf(err, \u0026#34;firstCall-\u0026gt;secondCall(%d)\u0026#34;, i) \t} \treturn nil }  // secondCall makes a call to a third function and wraps any error. func secondCall(i int) error { \tif err := thirdCall(); err != nil { \treturn errors.Wrap(err, \u0026#34;secondCall-\u0026gt;thirdCall()\u0026#34;) \t} \treturn nil }  // thirdCall create an error value we will validate. func thirdCall() error { \treturn \u0026amp;AppError{99} }   Go Playground\n输出是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  Custom App Error: 99  Stack Trace ******************************** App Error, State: 99 secondCall-\u0026gt;thirdCall() main.secondCall \t/tmp/sandbox3687093259/prog.go:60 main.firstCall \t/tmp/sandbox3687093259/prog.go:51 main.main \t/tmp/sandbox3687093259/prog.go:26 runtime.main \t/usr/local/go-faketime/src/runtime/proc.go:250 runtime.goexit \t/usr/local/go-faketime/src/runtime/asm_amd64.s:1571 firstCall-\u0026gt;secondCall(10) main.firstCall \t/tmp/sandbox3687093259/prog.go:52 main.main \t/tmp/sandbox3687093259/prog.go:26 runtime.main \t/usr/local/go-faketime/src/runtime/proc.go:250 runtime.goexit \t/usr/local/go-faketime/src/runtime/asm_amd64.s:1571  No Trace ******************************** firstCall-\u0026gt;secondCall(10): secondCall-\u0026gt;thirdCall(): App Error, State: 99  Program exited.   使用 %+v 打印调用栈上下文和用户上下文，使用 %v 只打印用户上下文。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap6/","summary":"6. Error Handling 6.1 Default Error Values 退出程序的两种方式：os.exit() 和 panic()，如果需要跟踪堆栈信息就用后者。 error 是接口，是解耦的，这很重要，提供了很大","title":"Ultimate Go Programming 笔记——第六章"},{"content":"5. 组合 在 Go 中，组合是最应该关注的事情，重要性甚至超过并发。\n5.1 Grouping Types Go 中没有子类型，也没有子类。\nGo 是按照能够做什么来分组的，而不是是什么。\n嵌入是为了行为，而不是状态，在 Go 中不要创建类似于抽象类的类型，如果两个类有相同的状态，直接复制粘贴它们，而不是给它们创建一个父类，如果这个父类不会真的被用到。\n如果一个抽象类型不是全新的类型，没有它自己独特的含义，就不要创建这个类型，比如说它有了和基类型不一样的方法它就是全新的了（比如 Duration 类型，它实际代表的是纳秒）。\n5.2 Decoupling 先解决具体的问题，然后再思考哪些部分可以解耦，让其能够更好地应对变化。\n先优化正确性，然后再考虑性能。\n函数比方法更加准确不容易出错，因为函数要把需要的数据直接作为参数传进去，而方法是从结构体的字段里取的，当结构体字段发生变化或者没被被初始化可能会导致运行时错误。\n从下到上构建 API，即从最基础的开始，完成之后思考哪些部分可以进行解耦来应对可能的数据变化。\n把借口当作没有值只有行为的变量。\n5.3 Conversion and Assertions v := I.(T) ，如果 I 可以转换成类型 T，那么 V 是原值的拷贝；如果不可以，会恐慌。\nv, ok := I.(T) ，如果 I 可以转换成类型 T，那么 V 是原值的拷贝；如果不可以，ok 是 false ，V 是类型 T 的零值。\n5,4 Interface Pollution Smells:\n The package declares an interface that matches the entire API of its own concrete type.（相当于重复了一遍） The interface is exported but the concrete type is unexported. The factory function returns the interface value with the unexported concrete type value inside. The interface can be removed and nothing changes for the user of the API.（搞了个寂寞） The interface is not decoupling the API from change.  Here are some guidelines around interface pollution: Use an interface:\n  When users of the API need to provide an implementation detail.\n  When API’s have multiple implementations that need to be maintained.\n  When parts of the API that can change have been identified and require decoupling.\n  Question an interface:\n  When its only purpose is for writing testable API’s (write usable API’s first).\n  When it’s not providing support for the API to decouple from change.\n  When it\u0026rsquo;s not clear how the interface makes the code better.\n  5.6 Design Guidelines Design Philosophy:\n Interfaces give programs structure. Interfaces encourage design by composition. Interfaces enable and enforce clean divisions between components.  The standardization of interfaces can set clear and consistent expectations.   Decoupling means reducing the dependencies between components and the types they use.  This leads to correctness, quality and performance.   Interfaces allow you to group concrete types by what they do.  Don\u0026rsquo;t group types by a common DNA but by a common behavior. Everyone can work together when we focus on what we do and not who we are.   Interfaces help your code decouple itself from change.  You must do your best to understand what could change and use interfaces to decouple. Interfaces with more than one method have more than one reason to change. Uncertainty about change is not a license to guess but a directive to STOP and learn more.   You must distinguish between code that:  defends against fraud vs protects against accidents    Validation:\nUse an interface when:\n users of the API need to provide an implementation detail. API’s have multiple implementations they need to maintain internally. parts of the API that can change have been identified and require decoupling.  Don\u0026rsquo;t use an interface:\n for the sake of using an interface. to generalize an algorithm. when users can declare their own interfaces. if it\u0026rsquo;s not clear how the interface makes the code better.  ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap5/","summary":"5. 组合 在 Go 中，组合是最应该关注的事情，重要性甚至超过并发。 5.1 Grouping Types Go 中没有子类型，也没有子类。 Go 是按照能够做什么来分组的，而不是是什么。 嵌入是","title":"Ultimate Go Programming 笔记——第五章"},{"content":"4. 解耦 4.1 方法 一切都是基于数据的，不理解数据就不理解问题，不理解问题就无法写代码。如果问题发生变化，那就意味着数据发生了变化，代码也必须要改变。但我们想要最小化需要改变的代码，这就是解耦的作用。\n解耦是通过行为实现的，行为是我们的设计和架构。但是要从从具体数据入手，不要从行为入手，如果从行为开始，那就是在猜测。正确顺序是首先解决具体的问题，然后努力实现解耦。\n方法的作用是允许数据有自己的行为。和 OOP 语言不同，OOP 中的对象总是有状态和行为，但是 Go 中大部分时候是把这两者分开，函数应该是第一选择，除非它是不合理的或不符合实际的。但问题是数据什么时候应该有行为呢？\n值和指针都可以直接调用使用值和指针声明的方法，Go 会自动调整，但是反复改变语义是很糟糕的。\n怎么选择值接收器和指针接收器？并不是根据是否需要改变数据决定的。其实是要与语义保持一致，数据驱动语义，一旦语义被选定，要么一切都是值，要么一切都是指针。\nGo 中的类型大致可以分为三种：\n内置类型，如数字类型、字符串和布尔，使用值语义，甚至都不应该看到任何指向这些类型的指针。例外：Unmarshal、Marshal。\n引用类型，如映射、切片、接口和通道，同样不应该有指向这些类型的指针，因为它们本来就被设计成可以共享的。例外：Decode、Unmarshal。\n结构体类型，如果不确定就使用指针语义，如果非常确定可以使用值语义就使用值语义。\n结构体中的字段同样应该遵守上述规则，标准库中的代码可以验证这一做法。这也是可以由多人维护一个代码库的关键所在。\n对结构体而言，可以参考真实世界中的规律来决定使用指针语义还是值语义。\n对于不熟悉的类型，参考工厂函数。\n拷贝共享的东西是很危险的，这是对语义法的重大违背。\n如果知道是什么语义在起作用，就知道行为。\n方法其实也是函数，自带语法糖而已。\n解耦会导致间接引用和内存分配，方法让我们有能力赋予数据行为，但是我们仍然需要学习什么时候数据有行为是合理和实用的，这应该是个意外而不是规则。\n4.2 接口 接口让我们获得多态的能力。\n\u0026ldquo;Polymorphism means that you write a certain program and it behaves differently depending on the (concrete) data that it operates on.\u0026rdquo; - Tom Kurtz (inventor of BASIC)\n数据什么时候需要拥有行为？一个好的理由是当我们需要实现多态的时候。\n接口只是定义了行为契约，它不是真实的，没有任何具体的东西。但是赋值的时候它会存储指向具体数据以及数据的类型的指针。\n编译器是爱我们的，它不希望我们写的代码导致完整性问题。\n值类型的方法集只包括使用值接收器定义的方法，而指针类型的方法集同时包括使用值接收器定义以及使用指针接收器定义的方法。但是为什么值类型的方法集不包括使用指针接收器定义的方法呢？\n次要的原因是不是所有的值都可以取地址的（比如说常量），而完整性的意思是百分百正确。\n主要原因是，如果工作在指针语义下，只允许共享，绝对不允许复制指针指向的值。但是有时候在值语义下共享是安全的（比如说 unmarshal）。当我们在接口内存储数据的时候，同样不能违反语义法。\n接口是引用类型，这意味着它使用的是值语义，但是共享数据。\n类型 T 只要实现了所有接口 I 定义的方法就实现了这个接口，不需要像 Java 那样显示地写出来，这也是 Go 约定优于配置的一个表现。\n4.3 嵌入 内部类型的方法可以被提升到外部类型。但这是组合，不是继承。\n如果嵌入的多个类型实现了相同的方法，只有使用了该方法编译器才会报错（歧义），如果没有使用的话就没任何问题。\n外部类型的方法会覆盖内部类型的同名方法。\n4.4 导出 Go 的约定之一：包的名字要和文件夹的名字一样，包是最小的编译单元。\nGo 的导不导出并不是 public 和 private，public 和 private 是关于数据的，导出是关于标识符的，Go 的编译器是可以访问所有内容的，导出的作用是让我们 coder 可以直接访问。\n类型级别封装中一个有意思的现象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Package users provides support for user management. package users  // user represents information about a user. type user struct { \tName string \tID int }  // Manager represents information about a manager. type Manager struct { \tTitle string  \tuser }   在 users 包以外是可以访问 u.Name 和 u.ID 的，即使 user 类型是未导出的。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap4/","summary":"4. 解耦 4.1 方法 一切都是基于数据的，不理解数据就不理解问题，不理解问题就无法写代码。如果问题发生变化，那就意味着数据发生了变化，代码也必须要改变","title":"Ultimate Go Programming 笔记——第四章"},{"content":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。\n如果数据变了，那么问题也就变了，如果问题变了，那么要使用的算法也就变了，有时候会导致连带变化，这时候就要关注如何把代码和数据的变化分离开来，以便将这些连带变化降到最低。如果在抽象的基础上再建立抽象，那就和正确性和可读性走远了，甚至会影响理解代码的心智模型的能力。我们需要解耦的平衡，要用薄的解耦层来应对变化。如果写代码的时候不确定要使用的数据，这时候不应该猜测，这是停下来的指示，转去思考摆在自己面前的数据转换是什么，不必知道所有的数据，但是只对自己有信心的部分编码，不要在今天写下明天的 bug。\n3.2 数组 缓存层次：\n酷睿 i7 系列 CPU 延迟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  3GHz(3 clock cycles/ns） * 4 instructions per cycle = 12 instructions per ns!  1 ns ............. 1 ns .............. 12 instructions (one） 1 µs .......... 1000 ns .......... 12,000 instructions (thousand） 1 ms ..... 1,000,000 ns ...... 12,000,000 instructions (million） 1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions (billion）  L1 - 64KB Cache (Per Core） \t4 cycles of latency at 1.3 ns \tStalls for 16 instructions  L2 - 256KB Cache (Per Core） \t12 cycles of latency at 4 ns \tStalls for 48 instructions  L3 - 8MB Cache \t40 cycles of latency at 13.3 ns \tStalls for 160 instructions  Main Memory \t100 cycle of latency at 33.3 ns \tStalled for 400 instructions   访问主存太慢了，所以需要缓存。访问主存的一个字节会导致读取和缓存整个缓存线（cache line），向缓存线中写一个字节也会导致写整个缓存线，一个缓存线的大小通常是 32 或 64 字节。\n可预测的访问模式也很重要，这样预取器（prefetcher）可以提前把需要的数据读到缓存里，所以说预取器喜欢数组，硬件喜欢数组，数组（在 Go 中其实是切片）真的是当今硬件中最重要的数据结构。\n比如说实践中通常采用线性数组遍历（比如说一行一行访问而不是一列一列访问）。\n缓存的缺失也可能导致快表（TLB）的缺失，这使得可预测的访问模式更加重要，它不仅有助于缓存线，还有助于确保 TLB 也是正确的缓存，这样对内存的访问才是尽可能快的。当今的性能并不是时钟有多快，而是如何有效地将数据在需要之前就把它送进处理器。\nfor i, v := range arr 创建数组本身的拷贝然后再遍历，而且 v 也是拷贝数组中元素的拷贝，但它的地址是不变的，即它是复用的。不要对数组的指针进行遍历，这样语义就太混乱了。\n3.3 切片 声明和长度和引用类型 切片和字符串类似，也是引用类型（这个视频把字符串、切片、映射、通道、接口和函数类型称作引用类型，因为它们的数据结构中包含指针，而且除了字符串的零值是空值外它们的零值都是 nil），它有三个字段分别是指向数组的指针、长度和容量。\n长度是从指针位置可以访问到的元素总数，容量是存在于指针指向的数组中的元素总数，容量可以比长度大反之则不行。\n引用类型使用的是值语义，目的是可以直接传值来共享数据并且开销很小且固定，因为它里面包含的是指向真正数据的指针，在复制时复制指针就可以了。\n追加 一个有趣的现象是，使用 var s1 []string 声明的切片是 nil 切片，而使用 s2 := []string{} 声明的切片是空切片，它们两个的意义并不一样，虽然它们的长度和容量都为0，但是空切片中的指针是指向空结构体的而 nil 切片中的指针也是 nil。这种差异可以用于判断返回值是否出错，如果返回 nil 可以认为是出错了，如果是空切片的话可以认为没有出错只不过返回的数据为空而已。\n在使用 append 函数时如果切片的长度和容量一样即满了则创建新的底层数组并且扩容，当需要的容量超过原切片容量的两倍时，会使用需要的容量作为新容量；当切片长度小于 1024 时容量翻倍，大于 1024 时会反复增加 25% 直到新容量超过所需要的容量。需要注意，切片使用值语义，在使用 append 时传递的是切片的拷贝，当然这个拷贝和原切片共享底层数组，所以使用 append 后最好把返回值赋给原切片，以免出现内存泄漏，即：\n1 2  s = append(s, value) s1 = append(s, value) // 不要这样   如果知道切片的长度的话就直接在创建时指定，这样就不用使用 append 了。\n切片的切片 切片值可以在栈上，底层数组才需要在堆上。\narr[a:b] 的意思是取切片或数组 arr 从 a 到 b 不包括 b 的部分，即前闭后开区间，所以最好使用长度来取切片即 arr[a:a+len]，这样比较不容易出错。\n取切片也存在副作用，因为切片的切片和原切片共享底层数组，所以如果改变其中一个切片两者共同索引区间内的元素那么另一个切片也会受到影响；另外一方面，如果子切片的容量比长度大，那么对其调用 append 时会直接改变它尾部后面的那个元素从而影响原切片，但是可以使用三个索引创建切片即 arr[a : b : b] 来解决这个问题，最后一个索引用来指定容量，这样这个切片的长度和容量就是一样的，如果再对其调用 append 函数则会创建新的底层数组。\n有时候需要使用 copy(dst, src) 来复制切片。\n切片和引用 如果有指向切片中某个元素的指针，然后这个切片扩容后改变了底层数组，导致原来的指针失效并且造成内存泄漏，这是非常烦人的 bug，所以对切片调用 append 时一定要注意检查是否会创建新的底层数组，如果会的话一定要再三检查是否有副作用。\nrange 机制 切片的 range 和数组一样也会创建切片的拷贝，如果在遍历过程中改变了原切片，使用值语义是不受影响的，但是使用指针语义会受影响：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Using the value semantic form of the for range. friends := []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for _, v := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, v) }  // Using the pointer semantic form of the for range. friends = []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for i := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, friends[i]) }  // Output: // v[Betty] // v[Charley] // v[Doug] // v[Edward] // v[Annie] // v[Betty] // panic: runtime error: index out of range [2] with length 2  // goroutine 1 [running]: // main.main() // /tmp/sandbox1154993090/prog.go:22 +0x2ae  // Program exited.   3.4 映射 映射的零值不可用，必须 make 或者使用字面量声明才可以用。\n映射使用值语义，它的值是原始值的拷贝而不是指针。\n映射的 range 循环得到的也是映射中键和值的拷贝。\n可以使用 delete(mp, key) 删除映射中的键，如果使用映射当作缓存则必须删除键来避免内存泄漏。\n映射的键必须是可哈希的，即可以出现在 if 中。\n映射的键是无序的，如果需要有序键的话要手动排序。\n映射也是引用类型，传递给函数有副作用。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap3/","summary":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。 如果数据变了，那么问题也就变了，如果问","title":"Ultimate Go Programming 笔记——第三章"},{"content":"如图：\n","permalink":"https://tiandiyijian.top/posts/goland%E5%92%8Cidea%E4%BD%BF%E7%94%A8cmder/","summary":"如图：","title":"Goland和IDEA使用cmder"},{"content":"1 2  $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系   这两行命令执行过之后会在当前 conda 环境的 bin 目录中生成这两个文件：\n1 2  x86_64-conda-linux-gnu-gcc x86_64-conda-linux-gnu-g++   为了方便使用可以用软链创建两个文件：\n1 2  $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-gcc ~/miniconda3(your conda path)/envs/(env)/bin/gcc $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-g++ ~/miniconda3(your conda path)/envs/(env)/bin/g++   然后重启一下环境应该就生效了。\n参考：\n如何改变anaconda 的 gcc 版本？ - 徐智明的回答 - 知乎 \n","permalink":"https://tiandiyijian.top/posts/conda%E5%AE%89%E8%A3%85gcc%E5%92%8Cg++/","summary":"1 2 $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系 这两行命令执行过之后会","title":"Conda安装gcc和g++"},{"content":"2.语言机制 2.1变量 Type is everything, type is life!\n类型提供了两个信息：内存大小和它的表示方法。\n如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明它。\n为了完整性（integrity），Go 没有 casting 机制，所以需要显示类型转换。\n2.2结构体 大小 如果要理解成本，必须要理解内存分配。\nCPU 访问内存是以字长（比如 32 位机器是 4 字节）为单位的，为了方便 CPU 访问即提高内存读写效率，结构体需要做内存对齐。\n内存对齐主要遵循下面三个原则：\n 结构体变量的起始地址能够被其最宽的成员大小整除 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节  Go语言中空结构体的大小为0，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的，但是空结构体有一个特例，那就是当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放），所以当struct{}作为结构体成员中最后一个字段时，要填充额外的内存保证安全。\n如果真的很需要做内存优化的话，可以把结构体中的字段按从大到小的顺序排列，但是最好还是按照语义顺序来，因为可读性才是最重要的。\n类型转换 字段完全相同（顺序也要相同）的命名类型之间赋值需要做显示转换，匿名类型可以直接赋值，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // example represents a type with different fields. type example struct { \tflag bool \tcounter int16 \tpi float32 }  type example2 struct { \tflag bool \tcounter int16 \tpi float32 }  func main() {  \t// Declare a variable of an anonymous type and init \t// using a struct literal. \te := struct { \tflag bool \tcounter int16 \tpi float32 \t}{ \tflag: true, \tcounter: 10, \tpi: 3.141592, \t}  \t// Create a value of type example. \tvar ex example \tvar ex2 example2  \t// ex = ex2 // cannot use ex2 (variable of type example2) as type example in assignment \tex = example(ex2)  \t// Assign the value of the unnamed struct type \t// to the named struct type value. \tex = e  \t// Display the values. \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, ex) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, e) }   2.3指针 传值 Go 只有传值，好处是提供了隔离性，局部的改动不会影响全局。坏处是可能影响性能，因为一份数据可能在程序中有多个拷贝，而且如果相同时改变这些拷贝有一定难度。\n共享数据 如果需要共享数据的话就需要传指针了，但是指针也是值，是地址的值而不是引用，取决于不同的操作系统一个指针会占用4字节或者8字节的空间，在传指针的时候会发生一次地址值的拷贝。另外，指针是字面量类型，它是有类型的，因为有了类型编译器才知道一种特定的指针可以做什么操作，Type is life！\n逃逸分析 栈能带来的好处不仅是 isolation 和 immutability 以及减少 side effects，还能在很多情况下带来更好的性能，因为它是自清理的，一个函数返回之后它的栈已经完全没用了，它上层的函数再进行函数调用时可以直接覆盖，不需要垃圾收集器。\n所以，如果要共享一个变量的话，就必须把它分配在堆上，然后返回它的指针即地址值。\n为了更好的可读性，一定要区分开什么时候使用值语义，什么时候使用指针语义。在构造过程中不要使用指针语义，如果需要共享它就在 return 时使用 \u0026amp; 操作符，这样一眼就能看出它是否逃逸到堆中。如果变量的生命从指针开始，那么就失去可读性了，因为它并不能告诉你它在内存中的位置。\n像这样的代码就非常折磨。\n另外，当编译器不知道某个变量的大小（比如切片）时，那么也会在堆上分配它的内存。栈并不是动态的，在编译期就已经确定。\n如果变量太大时，也会把它分配在堆上。\n栈增长 当栈空间（2K）满时，会扩容25%，然后把之前的内容拷贝到新栈上去，这意味这栈里面变量的内存地址是有可能发生改变的。既然栈的地址是可能发生变化的，在 Go 中，栈内存在 goroutine 之间是不能共享的。\n垃圾回收 影响性能的因素（1.3节）\n 网络和磁盘 IO 延迟 内存分配和垃圾回收 访问数据的方式和效率 算法  小堆、回收频率、时间短之间的平衡\n2.4常数 常数只在编译期存在，最少拥有256比特的精度。下面的程序可以通过编译，但是如果要使用 bigger 这个变量就会在编译期报溢出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how constants do have a parallel type system. package main  import \u0026#34;fmt\u0026#34;  const ( \t// Max integer value on 64 bit architecture. \tmaxInt = 9223372036854775807  \t// Much larger value than int64. \tbigger = 9223372036854775808543522345  \t// Will NOT compile \t// biggerInt int64 = 9223372036854775808543522345 )  func main() { \tfmt.Println(\u0026#34;Will Compile\u0026#34;) \t//fmt.Println(maxInt, bigger) }   常数是没有类型的，可以把它的类型理解为另一种东西——种类 kind，编译器会根据上下文做隐式转换（在函数传参的时候非常方便，不用做类型转换直接传一个字面量就行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how to declare constants and their // implementation in Go. package main  func main() {  \t// Constants live within the compiler. \t// They have a parallel type system. \t// Compiler can perform implicit conversions of untyped constants.  \t// Untyped Constants. \tconst ui = 12345 // kind: integer \tconst uf = 3.141592 // kind: floating-point  \t// Typed Constants still use the constant type system but their precision \t// is restricted. \tconst ti int = 12345 // type: int \tconst tf float64 = 3.141592 // type: float64  \t// ./constants.go:XX: constant 1000 overflows uint8 \t// const myUint8 uint8 = 1000  \t// Constant arithmetic supports different kinds. \t// Kind Promotion is used to determine kind in these scenarios.  \t// Variable answer will of type float64. \tvar answer = 3 * 0.333 // KindFloat(3) * KindFloat(0.333)  \t// Constant third will be of kind floating point. \tconst third = 1 / 3.0 // KindFloat(1) / KindFloat(3.0)  \t// Constant zero will be of kind integer. \tconst zero = 1 / 3 // KindInt(1) / KindInt(3)  \t// This is an example of constant arithmetic between typed and \t// untyped constants. Must have like types to perform math. \tconst one int8 = 1 \tconst two = 2 * one // int8(2) * int8(1) }   声明常量时可以使用 iota，它表示行数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how iota works. package main  import \u0026#34;fmt\u0026#34;  func main() {  \tconst ( \tA1 = iota // 0 : Start at 0 \tB1 = iota // 1 : Increment by 1 \tC1 = iota // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;1:\u0026#34;, A1, B1, C1)  \tconst ( \tA2 = iota // 0 : Start at 0 \tB2 // 1 : Increment by 1 \tC2 // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;2:\u0026#34;, A2, B2, C2)  \tconst ( \tA3 = iota + 1 // 1 : Start at 0 + 1 \tB3 // 2 : Increment by 1 \tC3 // 3 : Increment by 1 \t)  \tfmt.Println(\u0026#34;3:\u0026#34;, A3, B3, C3)  \tconst ( \tLdate = 1 \u0026lt;\u0026lt; iota // 1 : Shift 1 to the left 0. 0000 0001 \tLtime // 2 : Shift 1 to the left 1. 0000 0010 \tLmicroseconds // 4 : Shift 1 to the left 2. 0000 0100 \tLlongfile // 8 : Shift 1 to the left 3. 0000 1000 \tLshortfile // 16 : Shift 1 to the left 4. 0001 0000 \tLUTC // 32 : Shift 1 to the left 5. 0010 0000 \t)  \tfmt.Println(\u0026#34;Log:\u0026#34;, Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC) }   ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap2/","summary":"2.语言机制 2.1变量 Type is everything, type is life! 类型提供了两个信息：内存大小和它的表示方法。 如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明","title":"Ultimate Go Programming 笔记——第二章"},{"content":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现很多东西还是得记录一下的，脑子真的容易遗忘；二是意识到虽然自己写的很烂，但肯定会慢慢进步的，自己现在水平很低，但只要坚持学习，坚持记录，肯定会提高的。\n现在彻底决定毕业后搞开发不搞算法了，选择了 Go 语言，以前也听说过 hugo 这个生成器，就是用 Go 写的，遂决定尝试一下，还是遇到一些坑的，记录一下。\n添加搜索 因为搜索这个功能需要 index.json 这个文件，但默认是不生成的，需要在配置里打开：\n1 2 3 4 5 6  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON   另外，在生成的时候要加 -D 参数才可以，要不然不生成 /search这个路径对应的文件夹，访问的话会是 404 页面。官网查了一下这个参数的作用：\n1  -D, --buildDrafts include content marked as draft   看不太懂。。\n添加分类和标签 增加归档和搜索页面只需要创建 archives.md 和 search.md 这两个文件就行了，本来我还以为分类和标签也是这样，但是怎么试都不行，后来发现在配置文件里加上这几句就行了：\n1 2 3 4  taxonomies:  category: Categories  tag: Tags  series: series   上面这两个就是我碰见的耗时最多去解决的问题了，感觉 hugo 相关的内容在网上还不是很多，分享一下我的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195  baseURL: \u0026#39;https://tiandiyijian.top\u0026#39; languageCode: \u0026#39;en-us\u0026#39; title: 天地一键 paginate: 10 theme: PaperMod  publishDir: docs enableInlineShortcodes: true enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true  hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启  buildDrafts: false buildFuture: false buildExpired: false  #googleAnalytics: UA-123-45 # 谷歌统计 # Copyright: Sulv  paginate: 15 # 首页每页显示的文章数  minify:  disableXML: true  # minifyOutput: true  permalinks:  post: \u0026#34;/:title/\u0026#34;  # post: \u0026#34;/:year/:month/:day/:title/\u0026#34;  params:  env: production # to enable google analytics, opengraph, twitter-cards and schema.  title: ExampleSite  description: \u0026#34;ExampleSite description\u0026#34;  keywords: [Blog, Portfolio, PaperMod]  author: Me  # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors  # images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;]  DateFormat: \u0026#34;January 2, 2006\u0026#34;  defaultTheme: auto # dark, light  disableThemeToggle: false   ShowReadingTime: true  ShowShareButtons: true  ShowPostNavLinks: true  ShowBreadCrumbs: true  ShowCodeCopyButtons: false  disableSpecial1stPost: false  disableScrollToTop: false  comments: false  hidemeta: false  hideSummary: false  showtoc: false  tocopen: false   assets:  # disableHLJS: true # to disable highlight.js  # disableFingerprinting: true  favicon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon16x16: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon32x32: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  apple_touch_icon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  safari_pinned_tab: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;   # profile-mode  profileMode:  enabled: false # needs to be explicitly set  title: Haha  subtitle: \u0026#34;This is subtitle\u0026#34;  imageUrl: \u0026#34;#\u0026#34;  imageWidth: 120  imageHeight: 120  imageTitle: my image  buttons:  - name: Posts  url: posts  - name: Tags  url: tags   # home-info mode  homeInfoParams:  Title: \u0026#34;Hi there \\U0001F44B\u0026#34;  Content: Welcome to my blog   socialIcons:  - name: github  url: \u0026#34;https://github.com/tiandiyijian\u0026#34;   analytics:  google:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  bing:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  yandex:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;   cover:  hidden: true # hide everywhere but not in structured data  hiddenInList: true # hide on list pages and home  hiddenInSingle: true # hide on single page   editPost:  URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34;  Text: \u0026#34;Suggest Changes\u0026#34; # edit text  appendFilePath: true # to append file path to Edit link   # for search  # https://fusejs.io/api/options.html  fuseOpts:  isCaseSensitive: false  shouldSort: true  location: 0  distance: 1000  threshold: 0.4  minMatchCharLength: 0  keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;]   menu:  main:  - identifier: search  name: Search  url: /search/  weight: 5  - identifier: categories  name: Categories  url: /categories/  weight: 10  - identifier: tags  name: Tags  url: /tags/  weight: 20  - identifier: archives  name: Archive  url: /archives/  weight: 30   taxonomies:  category: Categories  tag: Tags  series: series  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON  markup:  goldmark:  renderer:  unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话  highlight:  # anchorLineNos: true  codeFences: true  guessSyntax: true  lineNos: true  # noClasses: false  # style: monokai  style: darcula   codeFences: true # 代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。  # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。  # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。  # lineNoStart：行号从编号几开始，一般从 1 开始。  # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true.  # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true.  # noClasses：使用 class 标签，而不是内嵌的内联样式  privacy:  vimeo:  disabled: false  simple: true   twitter:  disabled: false  enableDNT: true  simple: true   instagram:  disabled: false  simple: true   youtube:  disabled: false  privacyEnhanced: true  services:  instagram:  disableInlineCSS: true  twitter:  disableInlineCSS: true    我也还没全部搞懂上面的配置项都是啥意思，以后用的到时候再慢慢研究吧。有一说一，hugo 的速度好快啊。\n参考：\n【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://tiandiyijian.top/posts/hugo%E8%B8%A9%E5%9D%91/","summary":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现","title":"Hugo踩坑"}]