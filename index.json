[{"content":"客户端指本地的电脑，服务器指远程的电脑。比如在 A 上 ssh user@B，A 就是客户端，B 就是服务器。\nSSH 免密登录的原理是当从客户端连接 SSH 服务器的时候服务器会生成一个随机数，然后用客户端的公钥加密，然后把它发送给客户端，客户端用自己的私钥解密再发给服务器，如果服务器收到的随机数和它生成的一样那么就认证通过。所以 SSH 免密登录要做的就是把客户端的公钥放到服务器中，具体位置为 ~/.ssh/authorized_keys。\n如果客户端还没有密钥的话就要先生成一对：\n1  ssh-keygen -t rsa   rsa 是加密算法，现在貌似有一些版本不能用 rsa 要用 dsa， 不是特别清楚。这个命令会生成 id_rsa 和 id_ras.pub 两个文件，分别是公私钥。然后把公钥的内容写到服务器的 ~/.ssh/authorized_keys 文件中就行了，可以直接复制然后再粘贴过去，也可以把 id_rsa.pub 这个文件用 scp 传到服务器然后\n1  cat -n id_rsa.pub ~/.ssh/authorized_keys   追加写到 ~/.ssh/authorized_keys 就行了，道理都是一样的。然后服务器上 id_rsa.pub 这个文件就没用了可以删除，也不需要在服务器上生成公私钥。\n另外，如果服务器默认不允许公钥认证的话要更改 /etc/ssh/sshd_config 文件：\n1  PubkeyAuthentication yes   然后重启 SSH Server：\n1  service ssh restart   参考：\n在 SSH 中使用 RSA 和 DSA 认证（详解）-阿里云开发者社区\ncentos7 免密登陆 问题\nCentOS7.4配置SSH登录密码与密钥身份验证踩坑 - Leroscox - 博客园\n","permalink":"https://tiandiyijian.top/posts/ssh/","summary":"客户端指本地的电脑，服务器指远程的电脑。比如在 A 上 ssh user@B，A 就是客户端，B 就是服务器。 SSH 免密登录的原理是当从客户端连接 SSH 服务器的时候","title":"SSH 免密登录"},{"content":"前文已经完成了获取 peers 的功能。本文实现 peer 间通信和并发下载。\nPeer 间通信 定义结构体 Client 来进行 peer 间通信：\n1 2 3 4 5 6 7 8  type Client struct {  Conn net.Conn  Chocked bool  BitField bitfield.BitField  peer peer.Peer  infoHash [20]byte  peerID [20]byte }   客户端必须维护它与远程 peer 间连接的状态信息：\n  choked：远程 peer 是否阻塞客户端。当 peer 阻塞客户端时，peer 不会应答客户端发出的任何请求\n  interested：远程 peer 是否想要下载客户端拥有的资源，因为本文只实现下载功能，所以不会用到这个状态\n  注意远程 peer 也可能是客户端，想要下载自己的资源。\n握手 客户端要想和远程 peer 通信必须先发送握手信息，握手信息组成为：\n1  handshake: \u0026lt;pstrlen\u0026gt;\u0026lt;pstr\u0026gt;\u0026lt;reserved\u0026gt;\u0026lt;info_hash\u0026gt;\u0026lt;peer_id\u0026gt;     pstrlen： 的长度，占一个字节\n  pstr：总是 BitTorrent protocol（所以 pstrlen 总是 19），占 19 字节\n  reserved：8 个保留字节，全部设为 0。把他们当中某些设为 1 表示支持特定的扩展\n  infohash：.torrent 文件中 info 部分的 SHA-1 哈希值，占 20 字节，和前文中发送给 tracker 的 info_hash 一样\n  peer_id：和前文中发送给 tracker 的 peer_id 一样，占 20 字节\n  根据上述定义，定义结构体 Handshake：\n1 2 3 4 5 6 7 8 9 10 11 12 13  type Handshake struct {  Pstr string // always \u0026#34;BitTorrent protocol\u0026#34;  InfoHash [20]byte  PeerID [20]byte }  func New(infoHash, peerID [20]byte) *Handshake {  return \u0026amp;Handshake{  Pstr: \u0026#34;BitTorrent protocol\u0026#34;,  InfoHash: infoHash,  PeerID: peerID,  } }   客户端发送握手消息给远程 peer 后等待接收 peer 发来的握手消息，然后校验哈希值是否一致：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  func completeHandshake(conn net.Conn, infoHash, peerID [20]byte) (*handshake.Handshake, error) {  conn.SetDeadline(time.Now().Add(time.Second * 3))  defer conn.SetDeadline(time.Time{}) // Disable the deadline   req := handshake.New(infoHash, peerID)  _, err := conn.Write(req.Serialize())  if err != nil {  return nil, err  }   res, err := handshake.Read(conn)  if err != nil {  return nil, err  }   if !bytes.Equal(res.InfoHash[:], infoHash[:]) {  return nil, fmt.Errorf(\u0026#34;Expected infohash %x but got %x\u0026#34;, infoHash, res.InfoHash)  }   return res, nil }   消息 双方完成握手之后发送的消息格式都为：\n1  \u0026lt;length prefix\u0026gt;\u0026lt;message ID\u0026gt;\u0026lt;payload\u0026gt;     length prefix：4 字节大端整数\n  message ID：1 字节整数，表示消息类型\n  payload：取决于消息类型\n  有以下消息类型：\n  keep-alive: \u0026lt;len=0000\u0026gt;\n 让客户端不要断开连接，一般两分钟发一次。    choke: \u0026lt;len=0001\u0026gt;\u0026lt;id=0\u0026gt;\n choke 对方    unchoke: \u0026lt;len=0001\u0026gt;\u0026lt;id=1\u0026gt;\n unchoke 对方    interested: \u0026lt;len=0001\u0026gt;\u0026lt;id=2\u0026gt;\n 想要下载对方的资源，将发送请求资源消息    not interested: \u0026lt;len=0001\u0026gt;\u0026lt;id=3\u0026gt;\n 不想要下载对方的资源    have: \u0026lt;len=0005\u0026gt;\u0026lt;id=4\u0026gt; 通知对方自己拥有了哪个 piece（比如说刚下载好的）    bitfield: \u0026lt;len=0001+X\u0026gt;\u0026lt;id=5\u0026gt;\n 该类型消息仅在握手完成后立刻发送，指该 peer 拥有哪些 pieces，用一个比特表示一个 piece    request: \u0026lt;len=0013\u0026gt;\u0026lt;id=6\u0026gt;\n 表示请求资源，index 是 piece 的 index，begin 是偏移量，length 是长度，因为一次可能不会下载整个 piece，而是把 piece 再分成 block 来下载    piece: \u0026lt;len=0009+X\u0026gt;\u0026lt;id=7\u0026gt;\n 发送的资源，block 部分是资源内容    cancel: \u0026lt;len=0013\u0026gt;\u0026lt;id=8\u0026gt;\n  定义 Message 类型作为消息实体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  type messageID uint8  const (  // MsgChoke chokes the receiver  MsgChoke messageID = 0  // MsgUnchoke unchokes the receiver  MsgUnchoke messageID = 1  // MsgInterested expresses interest in receiving data  MsgInterested messageID = 2  // MsgNotInterested expresses disinterest in receiving data  MsgNotInterested messageID = 3  // MsgHave alerts the receiver that the sender has downloaded a piece  MsgHave messageID = 4  // MsgBitfield encodes which pieces that the sender has downloaded  MsgBitfield messageID = 5  // MsgRequest requests a block of data from the receiver  MsgRequest messageID = 6  // MsgPiece delivers a block of data to fulfill a request  MsgPiece messageID = 7  // MsgCancel cancels a request  MsgCancel messageID = 8 )  type Message struct {  ID messageID  Payload []byte }  // Serialize serializes a message into a buffer of the form // \u0026lt;length prefix\u0026gt;\u0026lt;message ID\u0026gt;\u0026lt;payload\u0026gt; // Interprets `nil` as a keep-alive message func (m *Message) Serialize() []byte {  if m == nil {  return make([]byte, 4)  }  length := uint32(len(m.Payload) + 1) // +1 for id  buf := make([]byte, 4+length)  binary.BigEndian.PutUint32(buf[0:4], length)  buf[4] = byte(m.ID)  copy(buf[5:], m.Payload)  return buf }  func Read(r io.Reader) (*Message, error) {  bufLength := make([]byte, 4)  _, err := io.ReadFull(r, bufLength)  if err != nil {  return nil, err  }   length := binary.BigEndian.Uint32(bufLength)  if length == 0 {  // keep-alive message  return nil, nil  }   bufContent := make([]byte, length)  _, err = io.ReadFull(r, bufContent)  if err != nil {  return nil, err  }   m := Message{  ID: messageID(bufContent[0]),  Payload: bufContent[1:],  }   return \u0026amp;m, nil }   一个可用的连接需要先完成握手再收到对方的 bitfield 消息才能进行后续的下载，所以把这两部分也作为构造函数的内容，这样构造出的客户端一定是可用的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  type Client struct {  Conn net.Conn  Chocked bool  BitField bitfield.BitField  peer peer.Peer  infoHash [20]byte  peerID [20]byte }  func completeHandshake(conn net.Conn, infoHash, peerID [20]byte) (*handshake.Handshake, error) {  conn.SetDeadline(time.Now().Add(time.Second * 3))  defer conn.SetDeadline(time.Time{}) // Disable the deadline   req := handshake.New(infoHash, peerID)  _, err := conn.Write(req.Serialize())  if err != nil {  return nil, err  }   res, err := handshake.Read(conn)  if err != nil {  return nil, err  }   if !bytes.Equal(res.InfoHash[:], infoHash[:]) {  return nil, fmt.Errorf(\u0026#34;Expected infohash %x but got %x\u0026#34;, infoHash, res.InfoHash)  }   return res, nil }  func recvBitField(conn net.Conn) (bitfield.BitField, error) {  conn.SetDeadline(time.Now().Add(time.Second * 5))  defer conn.SetDeadline(time.Time{}) // Disable the deadline   msg, err := message.Read(conn)  if err != nil {  return nil, err  }  if msg == nil {  err := fmt.Errorf(\u0026#34;expected bitfield but got %s\u0026#34;, msg)  return nil, err  }   if msg.ID != message.MsgBitfield {  err := fmt.Errorf(\u0026#34;expected bitfield but got %s\u0026#34;, msg)  return nil, err  }   return msg.Payload, nil }  // New connects with a peer, completes a handshake, and receives a handshake // returns an err if any of those fail. func New(peer peer.Peer, infoHash, PeerID [20]byte) (*Client, error) {  conn, err := net.DialTimeout(\u0026#34;tcp\u0026#34;, peer.String(), 3*time.Second)  fmt.Println(\u0026#34;dial peer\u0026#34;, peer.String())  if err != nil {  fmt.Println(\u0026#34;Dial peer failed. Error:\u0026#34;, err)  return nil, err  }   _, err = completeHandshake(conn, infoHash, PeerID)  if err != nil {  fmt.Println(\u0026#34;Handshake peer failed. Error:\u0026#34;, err)  return nil, err  }   bf, err := recvBitField(conn)  if err != nil {  conn.Close()  fmt.Println(\u0026#34;Receive peer bitfield failed. Error:\u0026#34;, err)  return nil, err  }   return \u0026amp;Client{  Conn: conn,  Chocked: true,  BitField: bf,  peer: peer,  infoHash: infoHash,  peerID: PeerID,  }, nil }   并发下载 把每一个 piece 看作一个需要下载的任务，把它们放到一个通道中让 worker 取出来下载，首先定义 PieceWork 结构体，它需要有 piece 的索引、哈希、大小信息：\n1 2 3 4 5  type pieceWork struct {  index int  hash [20]byte  length int }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  func (t *Torrent) Download() ([]byte, error) {  log.Println(\u0026#34;Starting download for\u0026#34;, t.Name)   // pieceQueue for piece to download  pieceQueue := make(chan *pieceWork, len(t.PieceHashes))  results := make(chan *pieceResult)  for index, pieceHash := range t.PieceHashes {  length := t.PieceLength  if left := t.Length - index*t.PieceLength; left \u0026lt; t.PieceLength {  // the last piece length may be less than piecelength  length = left  }  pieceQueue \u0026lt;- \u0026amp;pieceWork{index: index, hash: pieceHash, length: length}  }   for _, peer := range t.Peers {  go t.startDownloadWorker(peer, pieceQueue, results)  }   // Collect results  buf := make([]byte, t.Length)  collectedPieces := 0  for collectedPieces \u0026lt; len(t.PieceHashes) {  result := \u0026lt;-results   begin := result.index * t.PieceLength  end := begin + t.PieceLength  if end \u0026gt; t.Length {  end = t.Length  }   copy(buf[begin:end], result.buf)  collectedPieces++  }   close(pieceQueue)  return buf, nil }  func (t *Torrent) startDownloadWorker(peer peer.Peer, pieceQueue chan *pieceWork, results chan *pieceResult) {  c, err := client.New(peer, t.InfoHash, t.PeerID)  if err != nil {  log.Printf(\u0026#34;Could not handshake with %s. Error: %s. Disconnecting\\n\u0026#34;, peer.IP, err)  return  }  defer c.Conn.Close()  log.Printf(\u0026#34;Completed handshake with %s\\n\u0026#34;, peer.IP)   c.SendUnchoke() // remote peer can send msg  c.SendInterested() // want to download   for pw := range pieceQueue {  if !c.BitField.HasPiece(pw.index) {  pieceQueue \u0026lt;- pw  continue  }   buf, err := downloadPiece(c, pw)  if err != nil {  log.Println(\u0026#34;exiting worker with error:\u0026#34;, err)  pieceQueue \u0026lt;- pw  return  }   if !checkHash(pw.hash, buf) {  log.Printf(\u0026#34;Piece #%d failed integrity check\\n\u0026#34;, pw.index)  pieceQueue \u0026lt;- pw  return  }   c.SendHave(pw.index)  results \u0026lt;- \u0026amp;pieceResult{index: pw.index, buf: buf}  } }   创建一个通道作为任务队列，一个通道用来收集下载的数据。对每一个 peer 启动一个协程，它从任务队列中取任务来下载并把下载的数据发送到结果通道。因为通道是并发安全的，所以每一个协程取到的任务肯定都是不同的任务。在下载一个任务的时候，如果远程 peer 没有该 piece 或者下载出错或者下载到的数据的哈希值校验失败都要把该任务重新放到任务队列中，这样其他的协程才有机会获取到该任务，要不然可能会导致漏掉某些 piece。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  type pieceProgress struct {  index int  client *client.Client  buf []byte  downloaded int  requested int  backlog int }  func (p *pieceProgress) readMessage() error {  msg, err := p.client.Read()  if err != nil {  return err  }  if msg == nil {  return nil  }   switch msg.ID {  case message.MsgUnchoke:  p.client.Chocked = false  case message.MsgChoke:  p.client.Chocked = true  case message.MsgHave:  index, err := message.ParseHave(msg)  if err != nil {  return err  }  p.client.BitField.SetPiece(index)  case message.MsgPiece:  n, err := message.ParsePiece(p.index, p.buf, msg)  if err != nil {  return err  }  p.downloaded += n  p.backlog--  }   return nil }  func downloadPiece(c *client.Client, pw *pieceWork) ([]byte, error) {  progress := pieceProgress{  index: pw.index,  client: c,  buf: make([]byte, pw.length),  }   // Setting a deadline helps get unresponsive peers unstuck.  // 30 seconds is more than enough time to download a 256 KB piece  c.Conn.SetDeadline(time.Now().Add(time.Second * 6000))  defer c.Conn.SetDeadline(time.Time{})   for progress.downloaded \u0026lt; pw.length {  // If unchoked, send requests until have enough unfulfilled requests  if !c.Chocked {  for progress.backlog \u0026lt; MaxBacklog \u0026amp;\u0026amp; progress.requested \u0026lt; pw.length {  blockSize := MaxBlockSize  // Last block might be shorter than the typical block  if pw.length-progress.requested \u0026lt; blockSize {  blockSize = pw.length - progress.requested  }   err := c.SendRequest(pw.index, progress.requested, blockSize)  if err != nil {  return nil, err  }   progress.requested += blockSize  progress.backlog++  }  }   err := progress.readMessage()  if err != nil {  return nil, err  }  }   return progress.buf, nil }   在下载 piece 的时候并不是一次获取全部数据，而是把 piece 再分成 block 去下载，一个 block 的大小通常为 16 KB。但是下载的时候并不需要一个 block 一个 block 的下载，可以并发请求多个 block，MaxBacklog 为最大并发数。因为下载并不是一次请求就完成的，导致当前连接会有并发数、下载量等信息，以及当前连接也会有是否 choked 的状态，所以使用 pieceProgress 来管理当前下载的状态。要等当前连接不再是 choked 状态时才可以向 peer 发送请求，要不然发了也会被忽略。在等到不再是 choked 状态时只要没有达到最大并发数并且请求量没达到 piece 大小就一直向 peer 发送请求，并更新请求量和并发数。在收到 MsgPiece 回应时把收到的数据拷贝到 buf 里并更新下载量和并发数。\n效果展示 主函数为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  func main() {  inPath := os.Args[1]  outPath := os.Args[2]  file, _ := os.Open(inPath)   var tf torrentfile.TorrentFile  err := bencode.Unmarshal(file, \u0026amp;tf)  if err != nil {  log.Fatalln(\u0026#34;invalid torrent file\u0026#34;)  }   t, err := tf.ToTorrent()  if err != nil {  log.Fatalln(\u0026#34;torrentfile to torrent err\u0026#34;)  }   err = t.GetPeers()  if err != nil {  log.Fatalln(\u0026#34;get peers error\u0026#34;, err)  }   buf, err := t.Download()  if err != nil {  log.Fatalln(\u0026#34;download error\u0026#34;)  }   outFile, err := os.Create(outPath)  if err != nil {  log.Fatalln(\u0026#34;create file error\u0026#34;)  }  defer outFile.Close()  _, err = outFile.Write(buf)  if err != nil {  log.Fatalln(\u0026#34;write file error\u0026#34;)  } }   实测：\n代码Github地址。\n参考：\n  Building a BitTorrent client from the ground up in Go | Jesse Li (jse.li)\n  用GO从零建立BitTorrent客户端 – HaoranDeng\u0026rsquo;s blog – 会写点代码，会写点小说\n  BitTorrentSpecification - TheoryOrgBitTorrentSpecification - TheoryOrg\n  veggiedefender/torrent-client: Tiny BitTorrent client written in Go (github.com)\n  archeryue/go-torrent: a toy torrent client written in golang (github.com)\n  ","permalink":"https://tiandiyijian.top/posts/go-bt-2/","summary":"前文已经完成了获取 peers 的功能。本文实现 peer 间通信和并发下载。 Peer 间通信 定义结构体 Client 来进行 peer 间通信： 1 2 3 4 5 6 7 8 type Client struct { Conn net.Conn Chocked bool BitField bitfield.BitField peer peer.Peer infoHash [20]byte peerID [20]byte","title":"Golang 实现BT下载器（二）"},{"content":"最近几年有在使用PT（Private Tracker）站，主要是高校站点，近几年看的剧和电影几乎都是在PT站里下载的，虽然校园网平时上网很慢，但是ipv6速度还是很快的。前一阵子突然好奇BT下载的原理具体是啥，能不能用Go语言实现BT下载器，在网上搜了一下发现还真有人做了，于是自己学习实现了一下。\n什么是BT BT，顾名思义，就是变态，是 BitTorrent（比特洪流）的简称。BitTorrent 是一种 P2P（peer-to-peer）协议，BitTorrent 网络中的用户被称作 peer，每个 peer 都是向别的 peer 请求资源，即 peer 在下载的同时也拥有上传的能力，这样的好处是用户越多，下载同一文件的人越多，下载该文件的速度越快，与传统的C/S模式中所有的用户只能向同一个服务器请求资源明显不同。\n获取 Peers 第一个问题就是怎么发现别的 peers，这就是 tracker 的作用，根据维基百科定义，tracker 是收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。那么 tracker 又在哪呢？这就是 .torrent 文件的作用，我们一般都把 .torrent 文件叫做种子文件，但其实 torrent 的中文意思是洪流，把通过一个 tracker 服务器连接起来的 peers 网络称作一个洪流，还挺形象的。\n解析 .torrent 文件 .torrent 文件使用 Bencode（发音为 bee-encode）进行了编码。Bencode 使用 ASCII 字符进行编码：\n  Integer 编码为 i\u0026lt;10进制编码整数\u0026gt;e，如 i7e 表示整数 7\n  Byte string 编码为 :，如 4:spam 表示字符串 \u0026ldquo;spam\u0026rdquo;\n  List 编码为 le，如 l4:spam4:eggse 表示 [\u0026quot;spam\u0026quot;, \u0026quot;eggs\u0026quot;]，list 可以包含任何其他类型的 bencoded value\n  Dictionary 编码为 de，如 d3:cow3:moo4:spam4:eggse 表示字典：{ \u0026quot;cow\u0026quot; : \u0026quot;moo\u0026quot;, \u0026quot;spam\u0026quot; : \u0026quot;eggs\u0026quot; }\n  如文件 debian-11.4.0-amd64-netinst.iso.torrent 的内容为：\n1  d8:announce41:http://bttracker.debian.org:6969/announce7:comment35:\u0026#34;Debian CD from cdimage.debian.org\u0026#34;13:creation datei1657367679e9:httpseedsl145:https://cdimage.debian.org/cdimage/release/11.4.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-11.4.0-amd64-netinst.iso145:https://cdimage.debian.org/cdimage/archive/11.4.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-11.4.0-amd64-netinst.isoe4:infod6:lengthi397410304e4:name31:debian-11.4.0-amd64-netinst.iso12:piece lengthi262144e6:pieces30320:(binary blob of the hashes of each piece)   把它转换成更好看的形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  d  8:announce  41:http://bttracker.debian.org:6969/announce  7:comment  35:\u0026#34;Debian CD from cdimage.debian.org\u0026#34;  13:creation date  i1657367679e  9:httpseeds  l  145:https://cdimage.debian.org/cdimage/release/11.4.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-11.4.0-amd64-netinst.iso  145:https://cdimage.debian.org/cdimage/archive/11.4.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-11.4.0-amd64-netinst.iso  e  4:info  d  6:length  i351272960e  4:name  31:debian-10.2.0-amd64-netinst.iso  12:piece length  i262144e  6:pieces  26800:�\u001f�\u000f���PS�^�� (binary blob of the hashes of each piece)  e e   这个文件中包括 tracker 的 URL、创建时间、文件的大小和名称、piece 的大小以及所有 piece 的 SHA-1 哈希值的 BLOB （binary large object）。httpseeds 字段是后续为了支持通过 HTTP 协议分发数据的拓展，本文不使用这个功能，可以直接忽略。\n实现 Bencode 解析器 所以要解析 .torrent 文件就需要一个 bencode 解析器，网上已经有现成的了，但是我没有写过这种解析器，所以就参考这个项目写了一个。\n首先定义以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  type BType uint8 type BVal interface{}  const (  BINT BType = iota  BSTR  BLIST  BDICT )  type BObj struct {  type_ BType  val_ BVal }   把任意 bencode 编码的对象表示为一个 BObj，它有类型和值两个字段，又因为具体值的类型是不确定的，所以使用空接口类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  func Decode(r io.Reader) (*BObj, error) {  br, ok := r.(*bufio.Reader)  if !ok {  br = bufio.NewReader(r)  }   b, err := br.Peek(1)  if err != nil {  return nil, err  }   switch {  case b[0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; b[0] \u0026lt;= \u0026#39;9\u0026#39;:  s, err := DecodeString(br)  if err != nil {  return nil, err  }   return NewBObj(BSTR, s), nil  case b[0] == \u0026#39;i\u0026#39;:  num, err := DecodeInt(br)  if err != nil {  return nil, err  }   return NewBObj(BINT, num), nil  case b[0] == \u0026#39;l\u0026#39;:  br.ReadByte() // start l  var list []*BObj  for {  b, err := br.Peek(1)  if err != nil {  return nil, err  }   if b[0] == \u0026#39;e\u0026#39; { // end e  br.ReadByte()  return NewBObj(BLIST, list), nil  }   bobj, err := Decode(br)  if err != nil {  return nil, err  }  list = append(list, bobj)  }  case b[0] == \u0026#39;d\u0026#39;:  br.ReadByte() // start d  dict := map[string]*BObj{}  for {  b, err := br.Peek(1)  if err != nil {  return nil, err  }   if b[0] == \u0026#39;e\u0026#39; { // end e  br.ReadByte()  return NewBObj(BDICT, dict), nil  }   key, err := DecodeString(br)  if err != nil {  return nil, err  }   bobj, err := Decode(br)  if err != nil {  return nil, err  }  dict[key] = bobj  }  }   return nil, ErrIvd }   解码函数思路是首先根据开头判断数据类型，然后去解析，如果是 List 或 Dictionary 类型直接循环递归处理就行了，在循环中检查下一个待读取的字符是不是 \u0026rsquo;e\u0026rsquo; ，如果是的话那么一定是该 BObj 最后一个 \u0026rsquo;e\u0026rsquo;，因为它嵌套的 BObj 一定会把前面的 \u0026rsquo;e\u0026rsquo;（如果有的话，当嵌套了 List 和 Dictionary 和 Integer 类型时会有）读取出来 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  func (o *BObj) Encode(w io.Writer) (int, error) {  bw, ok := w.(*bufio.Writer)  if !ok {  bw = bufio.NewWriter(w)  }   curLen := 0  switch o.type_ {  case BINT:  num, _ := o.Int()  wLen, err := EncodeInt(bw, num)  if err != nil {  return 0, err  }  curLen += wLen  case BSTR:  s, _ := o.Str()  wLen, err := EncodeStr(bw, s)  if err != nil {  return 0, err  }  curLen += wLen  case BLIST:  list, _ := o.List()   curLen += 1  bw.WriteByte(\u0026#39;l\u0026#39;)   for _, bobj := range list {  wLen, err := bobj.Encode(bw)  if err != nil {  return 0, err  }  curLen += wLen  }   curLen += 1  bw.WriteByte(\u0026#39;e\u0026#39;)  case BDICT:  dict, _ := o.Dict()   curLen += 1  bw.WriteByte(\u0026#39;d\u0026#39;)   for key, bobj := range dict {  wLen, err := EncodeStr(bw, key)  if err != nil {  return 0, err  }  curLen += wLen   wLen, err = bobj.Encode(bw)  if err != nil {  return 0, err  }  curLen += wLen  }   curLen += 1  bw.WriteByte(\u0026#39;e\u0026#39;)  }   if err := bw.Flush(); err != nil {  return 0, err  }   return curLen, nil }   编码函数思路和解码函数差不多，直接判断 BObj 的类型然后去编码，如果是 List 或 Dictionary 类型同样去循环递归处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  func Unmarshal(r io.Reader, s interface{}) error {  o, err := Decode(r)  if err != nil {  return err  }   v := reflect.ValueOf(s)  if v.Kind() != reflect.Ptr {  return errors.New(\u0026#34;dst must be a pointer\u0026#34;)  }   switch o.type_ {  case BLIST:  list, _ := o.List()  l := reflect.MakeSlice(v.Elem().Type(), len(list), len(list))  v.Elem().Set(l)  err = unmarshalList(list, v)  if err != nil {  return err  }  case BDICT:  dict, _ := o.Dict()  err := unmarshalDict(dict, v)  if err != nil {  return err  }  default:  return errors.New(\u0026#34;src must be struct or slice\u0026#34;)  }   return err }   Unmarshal 函数首先利用之前的解码函数得到一个 BObj， 然后利用这个 BObj 去反序列化。反序列化的目标只能是切片或者结构体类型，输入是它们的指针。如果是 List 的话要先利用反射把切片的长度设置好。重点是 unmarshalList 和 UnmarshalDict 这两个函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  func unmarshalList(list []*BObj, v reflect.Value) error {  if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Slice {  return errors.New(\u0026#34;dst must be pointer of slice\u0026#34;)  }   v = v.Elem()  if len(list) == 0 {  return nil  }   switch list[0].type_ {  case BSTR:  for i, bObj := range list {  s, err := bObj.Str()  if err != nil {  return err  }  v.Index(i).SetString(s)  }  case BINT:  for i, bObj := range list {  num, err := bObj.Int()  if err != nil {  return err  }  v.Index(i).SetInt(int64(num))  }  case BLIST:  if v.Type().Elem().Kind() != reflect.Slice {  return ErrTyp  }  for i, bObj := range list {  bList, err := bObj.List()  if err != nil {  return err  }   newPtr := reflect.New(v.Type().Elem())  newSlice := reflect.MakeSlice(v.Type().Elem(), len(bList), len(bList))  newPtr.Elem().Set(newSlice)  err = unmarshalList(bList, newPtr)  if err != nil {  return err  }  v.Index(i).Set(newPtr.Elem())  }  case BDICT:  if v.Type().Elem().Kind() != reflect.Struct {  return ErrTyp  }  for i, bObj := range list {  bDict, err := bObj.Dict()  if err != nil {  return err  }   newPtr := reflect.New(v.Type().Elem())  err = unmarshalDict(bDict, newPtr)  if err != nil {  return err  }  v.Index(i).Set(newPtr.Elem())  }  }   return nil }   unmarshalList 函数首先判断输入的 v 只能是切片的指针类型，要不然不能 Set。输入 list 中的元素的类型肯定都是一样的，对应切片中元素的类型，所以只判断第一个元素的类型就可以了，然后去循环设置每一个位置的元素。整数和字符串的情况比较简单，不再赘述。\n对于 BLIST 类型，先判断输入 v 的类型的的基本元素（v.Type().Elem() 的返回值也是 reflect.Type 类型，指的是当前类型的基本元素类型，只针对指针、数组、切片、映射、通道类型才是有效的，要和 v.Elem() 区分开，该函数的返回值类型是 reflect.Value，只针对指针和接口类型才有效，指的就是 v 指向的值）也是切片类型才可以正确进行反序列化。判断完成之后再去循环设置，每一次循环都先获取到当前位置对应的 bList 然后创建一个切片的指针，设置其长度和容量，再进行递归处理。最后设置该位置的元素。\n对于 BDICT 类型，过程和 BLIST 类型类似。unmarshalDict 函数和 unmarshalList 基本一致，只不过因为每一个字段的类型可能是不一样的，所以要在每一次循环里面判断类型。另外就是 tag 的处理，过程也比较简单：\n1 2 3 4 5 6 7  fieldType := v.Type().Field(i) key := fieldType.Tag.Get(\u0026#34;bencode\u0026#34;) if key == \u0026#34;\u0026#34; {  key = strings.ToLower(fieldType.Name) }  bObj, ok := bDict[key]   Marshal 函数就比较简单了，直接判断当前值的类型然后去编码就行了，过程跟编码函数基本一致：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  func Marshal(w io.Writer, i interface{}) (int, error) {  v := reflect.ValueOf(i)  if v.Kind() == reflect.Ptr {  v = v.Elem()  }  return marshalValue(w, v) }  func marshalValue(w io.Writer, v reflect.Value) (int, error) {  curLen := 0  switch v.Kind() {  case reflect.Int:  wLen, err := EncodeInt(w, int(v.Int()))  if err != nil {  return 0, err  }   curLen += wLen  case reflect.String:  wLen, err := EncodeStr(w, v.String())  if err != nil {  return 0, err  }   curLen += wLen  case reflect.Slice:  wLen, err := marshalList(w, v)  if err != nil {  return 0, err  }   curLen += wLen  case reflect.Struct:  wLen, err := marshalDict(w, v)  if err != nil {  return 0, err  }   curLen += wLen  default:  return 0, errors.New(\u0026#34;unsupported type\u0026#34;)  }   return curLen, nil }  func marshalList(w io.Writer, v reflect.Value) (int, error) {  curLen := 1  w.Write([]byte{\u0026#39;l\u0026#39;})   for i := 0; i \u0026lt; v.Len(); i++ {  curV := v.Index(i)  wLen, err := marshalValue(w, curV)  if err != nil {  return 0, err  }  curLen += wLen  }   w.Write([]byte{\u0026#39;e\u0026#39;})  return curLen + 1, nil }  func marshalDict(w io.Writer, v reflect.Value) (int, error) {  curLen := 1  w.Write([]byte{\u0026#39;d\u0026#39;})   for i := 0; i \u0026lt; v.NumField(); i++ {  field := v.Field(i)  fieldType := v.Type().Field(i)   key := fieldType.Tag.Get(\u0026#34;bencode\u0026#34;)  if key == \u0026#34;\u0026#34; {  key = strings.ToLower(fieldType.Name)  }   wLen, err := EncodeStr(w, key)  if err != nil {  return 0, err  }  curLen += wLen   wLen, err = marshalValue(w, field)  if err != nil {  return 0, err  }  curLen += wLen  }   w.Write([]byte{\u0026#39;e\u0026#39;})  return curLen + 1, nil }   使用 bencode 解析器解析 .torrent 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  type Info struct {  Length int `bencode:\u0026#34;length\u0026#34;`  Name string `bencode:\u0026#34;name\u0026#34;`  PieceLength int `bencode:\u0026#34;piece length\u0026#34;`  Pieces string `bencode:\u0026#34;pieces\u0026#34;` }  type TorrentFile struct {  Announce string `bencode:\u0026#34;announce\u0026#34;`  Info Info `bencode:\u0026#34;info\u0026#34;` }  var tf torrentfile.TorrentFile file, _ := os.Open(\u0026#34;xxx.torrent\u0026#34;) err := bencode.Unmarshal(file, \u0026amp;tf) if err != nil {  log.Fatalln(\u0026#34;invalid torrent file\u0026#34;) }   以上就完成了 .torrent 文件的解析\n从 tracker 获取 peers 首先定义一个新的结构体，与序列化结构体区分开，作为应用结构体：\n1 2 3 4 5 6 7 8 9 10  type Torrent struct {  Announce string  Name string  Length int  InfoHash [20]byte  PieceLength int  PieceHashes [][20]byte  Peers []peer.Peer  PeerID [20]byte }   TorrentFile 实现向 Torrent 转换的方法 ToTorrent：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  func (i *Info) Hash() ([20]byte, error) {  var buf bytes.Buffer  _, err := bencode.Marshal(\u0026amp;buf, *i)  if err != nil {  return [20]byte{}, err  }  h := sha1.Sum(buf.Bytes())  return h, nil }  func (i *Info) splitPieceHashes() ([][20]byte, error) {  hashLen := 20  buf := []byte(i.Pieces)  if len(buf)%hashLen != 0 {  return nil, fmt.Errorf(\u0026#34;malformed pieces hash length: %d\u0026#34;, len(buf))  }   numHashes := len(buf) / hashLen  hashes := make([][20]byte, numHashes)   for i := 0; i \u0026lt; numHashes; i++ {  copy(hashes[i][:], buf[i*hashLen:(i+1)*hashLen])  }   return hashes, nil }  func (tf *TorrentFile) ToTorrent() (torrent.Torrent, error) {  infoHash, err := tf.Info.Hash()  if err != nil {  return torrent.Torrent{}, err  }   pieceHashes, err := tf.Info.splitPieceHashes()  if err != nil {  return torrent.Torrent{}, err  }   return torrent.Torrent{  Announce: tf.Announce,  Name: tf.Info.Name,  Length: tf.Info.Length,  InfoHash: infoHash,  PieceLength: tf.Info.PieceLength,  PieceHashes: pieceHashes,  }, nil }   Torrent 获取 Peers 的方法为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  type TrackerResp struct {  Interval int `bencode:\u0026#34;interval\u0026#34;`  Peers string `bencode:\u0026#34;peers\u0026#34;` }  func (t *Torrent) buildTrackerURL(peerID [20]byte, port uint16) (string, error) {  base, err := url.Parse(t.Announce)  if err != nil {  return \u0026#34;\u0026#34;, err  }  params := url.Values{  \u0026#34;info_hash\u0026#34;: []string{string(t.InfoHash[:])},  \u0026#34;peer_id\u0026#34;: []string{string(peerID[:])},  \u0026#34;port\u0026#34;: []string{strconv.Itoa(int(Port))},  \u0026#34;uploaded\u0026#34;: []string{\u0026#34;0\u0026#34;},  \u0026#34;downloaded\u0026#34;: []string{\u0026#34;0\u0026#34;},  \u0026#34;compact\u0026#34;: []string{\u0026#34;1\u0026#34;},  \u0026#34;left\u0026#34;: []string{strconv.Itoa(t.Length)},  }  base.RawQuery = params.Encode()  return base.String(), nil }  func (t *Torrent) GetPeers() error {  _, err := rand.Read(t.PeerID[:])  if err != nil {  return err  }   url, err := t.buildTrackerURL(t.PeerID, uint16(Port))   c := \u0026amp;http.Client{Timeout: 15 * time.Second}  resp, err := c.Get(url)  if err != nil {  return err  }  defer resp.Body.Close()   res, err := io.ReadAll(resp.Body)  var tr TrackerResp  err = bencode.Unmarshal(bytes.NewBuffer(res), \u0026amp;tr)  if err != nil {  return err  }   peers, err := peer.Unmarshal([]byte(tr.Peers))  if err != nil {  return err  }   t.Peers = peers  return nil }   在向 tracker 请求的参数中：\n  info_hash：.torrent 文件中 info 部分的 SHA-1 哈希值，tracker 用这个确认想要下载哪个文件，这样才能确认拥有这个文件的 peers\n  peer_id：客户端的 ID，如”utorrent-xxx“，标识客户端软件和版本，本文直接用随机生成的\n  port：客户端监听的端口号\n  uploaded：总上传量\n  downloaded：总下载量\n  compact：设为 1 表示使用紧凑模式，每个 peer 用六个字节表示，前四个是 IP 地址后两个是端口号\n  left：剩余下载量\n  Tracker 发回的响应也是 bencode 编码的格式，可以用上文实现的 bencode 解析器直接反序列化得到 TrackerResp 结构体，其中包括两个字段：Interval 表示应该隔多久再次连接到 tracker 来更新 peers 列表，Peers 是一个包含上文提到的 6 字节地址的 BLOB，定义 Peer 结构体来解析它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  type Peer struct {  IP net.IP  Port uint16 }  func Unmarshal(peersBin []byte) ([]Peer, error) {  const peerSize = 6 // 4 for ip, 2 for port  if len(peersBin)%peerSize != 0 {  return nil, fmt.Errorf(\u0026#34;malformed binary peers length: %d\u0026#34;, len(peersBin))  }   numPeers := len(peersBin) / peerSize  peers := make([]Peer, numPeers)  for i := 0; i \u0026lt; numPeers; i++ {  offset := i * peerSize  //peers[i].IP = net.IP(peersBin[offset : offset+4])  peers[i].IP = peersBin[offset : offset+4]  peers[i].Port = binary.BigEndian.Uint16(peersBin[offset+4 : offset+6])  }   return peers, nil }   到此，已经获取到了拥有 .torrent 中文件的 peers。下篇实现 peer 间通信和并发下载。\n代码Github地址。\n参考：\n  Building a BitTorrent client from the ground up in Go | Jesse Li (jse.li)\n  用GO从零建立BitTorrent客户端 – HaoranDeng\u0026rsquo;s blog – 会写点代码，会写点小说\n  BitTorrentSpecification - TheoryOrgBitTorrentSpecification - TheoryOrg\n  veggiedefender/torrent-client: Tiny BitTorrent client written in Go (github.com)\n  archeryue/go-torrent: a toy torrent client written in golang (github.com)\n  ","permalink":"https://tiandiyijian.top/posts/go-bt/","summary":"最近几年有在使用PT（Private Tracker）站，主要是高校站点，近几年看的剧和电影几乎都是在PT站里下载的，虽然校园网平时上网很慢，","title":"Golang 实现BT下载器（一）"},{"content":"6. Error Handling 6.1 Default Error Values 退出程序的两种方式：os.exit() 和 panic()，如果需要跟踪堆栈信息就用后者。\nerror 是接口，是解耦的，这很重要，提供了很大的灵活性，因为 error 分布很广泛，我们希望可以改进和重构错误处理而不在代码库中产生大量的级联变化。\nError() 方法的作用只应该是 log，所以这个方法返回的结果应该是直接能用的而不需要让用户自己去解析，即不能让用户通过解析来获取上下文信息。\n最好用指针语义来实现error接口\n使用快乐路径处理错误情况，不要用 else，太复杂，如果需要的话就用 switch。\n6.2 Error Variables 当函数只返回一个值并且上下文不复杂的时候使用 errorString 类型的全局变量就行。如：\n1 2 3 4 5 6 7  var (  // ErrBadRequest is returned when there are problems with the request.  ErrBadRequest = errors.New(\u0026#34;Bad Request\u0026#34;)   // ErrPageMoved is returned when a 301/302 is returned.  ErrPageMoved = errors.New(\u0026#34;Page Moved\u0026#34;) )   6.3 Type as Context Type as context, applies when we\u0026rsquo;re goona need our own custom error types.\n用 switch 语句判断类型，e 是原值的拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() {  var u user  err := Unmarshal([]byte(`{\u0026#34;name\u0026#34;:\u0026#34;bill\u0026#34;}`), u) // Run with a value and pointer.  if err != nil {  switch e := err.(type) {  case *UnmarshalTypeError:  fmt.Printf(\u0026#34;UnmarshalTypeError: Value[%s] Type[%v]\\n\u0026#34;, e.Value, e.Type)  case *InvalidUnmarshalError:  fmt.Printf(\u0026#34;InvalidUnmarshalError: Type[%v]\\n\u0026#34;, e.Type)  default:  fmt.Println(err)  }  return  }   fmt.Println(\u0026#34;Name:\u0026#34;, u.Name) }   我们希望能在我们能做到的范围内用解耦的状态处理错误，因为从解耦的状态切换到具体的状态，那么任何针对这些具体类型做的关于错误处理的改进都可能引起级联变化。\n但是当需要跨越程序边界移动具体的数据时（两边都需要对具体数据本身进行处理），类型作为上下文是非常强大的。\n怎么能够使用自定义错误类型又不进入具体内容呢？这就是接下来要讨论的行为即上下文的想法。\n6.4 Behavior as Context 自定义错误类型可能不只有状态，也有行为。比如下面这个 net 包中错误类型的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  package example  import (  \u0026#34;bufio\u0026#34;  \u0026#34;fmt\u0026#34;  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;net\u0026#34; )  // client represents a single connection in the room. type client struct {  name string  reader *bufio.Reader }  // TypeAsContext shows how to check multiple types of possible custom error // types that can be returned from the net package. func (c *client) TypeAsContext() {  for {  line, err := c.reader.ReadString(\u0026#39;\\n\u0026#39;)  if err != nil {  switch e := err.(type) {  case *net.OpError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   case *net.AddrError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   case *net.DNSConfigError:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   default:  if err == io.EOF {  log.Println(\u0026#34;EOF: Client leaving chat\u0026#34;)  return  }   log.Println(\u0026#34;read-routine\u0026#34;, err)  }  }   fmt.Println(line)  } }  // temporary is declared to test for the existence of the method coming // from the net package. type temporary interface {  Temporary() bool }  // BehaviorAsContext shows how to check for the behavior of an interface // that can be returned from the net package. func (c *client) BehaviorAsContext() {  for {  line, err := c.reader.ReadString(\u0026#39;\\n\u0026#39;)  if err != nil {  switch e := err.(type) {  case temporary:  if !e.Temporary() {  log.Println(\u0026#34;Temporary: Client leaving chat\u0026#34;)  return  }   default:  if err == io.EOF {  log.Println(\u0026#34;EOF: Client leaving chat\u0026#34;)  return  }   log.Println(\u0026#34;read-routine\u0026#34;, err)  }  }   fmt.Println(line)  } }   用到的三种错误类型都有 Temporary 方法并且都使用这个方法，所以可以自定义一个 temporary 接口。\n当使用自定义错误类型时，一般遵循这个规则：如果自定义错误类型有以下四个方法中的其中一种，那么这个类型最好被定义为具有未导出字段的未导出类型，从而强迫用户不能从一个解耦的状态转换到具体的。这四个方法分别是：Temporary、time out、not found、not authorized。\n6.4 Find the Bug 如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show see if the class can find the bug. package main  import \u0026#34;log\u0026#34;  // customError is just an empty struct. type customError struct{}  // Error implements the error interface. func (c *customError) Error() string { \treturn \u0026#34;Find the bug.\u0026#34; }  // fail returns nil values for both return types. func fail() ([]byte, *customError) { \treturn nil, nil }  func main() { \tvar err error \tif _, err = fail(); err != nil { \tlog.Fatal(\u0026#34;Why did this fail?\u0026#34;) \t}  \tlog.Println(\u0026#34;No Error\u0026#34;) }   Go Playground\n这段代码会报错，理论上来说不应该报错的，因为 fail 返回的 error 是 nil，但是为什么会会报错呢？实际上，接口会存储它所包含变量的类型和值，只有当类型和值都为空时它才为空即等于 nil，在这里 err 的值虽然为空，但是它的类型是 *customError ，所以造成了这种现象。可以参考这段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show see if the class can find the bug. package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; )  // customError is just an empty struct. type customError struct{}  // Error implements the error interface. func (c *customError) Error() string { \treturn \u0026#34;Find the bug.\u0026#34; }  // fail returns nil values for both return types. func fail() ([]byte, *customError) { \treturn nil, nil }  func main() { \tvar err error \tfmt.Printf(\u0026#34;Type of value stored inside the interface: %T\\n\u0026#34;, err)  \tif _, err = fail(); err != nil { \tfmt.Printf(\u0026#34;Type of value stored inside the interface: %T\\n\u0026#34;, err) \t}  \tlog.Println(\u0026#34;No Error\u0026#34;) }   Go Playground\n这段代码的输出是：\n1 2 3  Type of value stored inside the interface: \u0026lt;nil\u0026gt; Type of value stored inside the interface: *main.customError 2009/11/10 23:00:00 No Error   如果使用 struct 自定义错误类型，最好使用指针语义。看下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how the default error type is implemented. package main  import \u0026#34;fmt\u0026#34;  // http://golang.org/pkg/builtin/#error type error interface { \tError() string }  // http://golang.org/src/pkg/errors/errors.go type errorString struct { \ts string }  // http://golang.org/src/pkg/errors/errors.go func (e *errorString) Error() string { \treturn e.s }  // http://golang.org/src/pkg/errors/errors.go // New returns an error that formats as the given text. func New(text string) error { \treturn \u0026amp;errorString{text} }  var bad = New(\u0026#34;Bad Request\u0026#34;)  func main() { \tif err := webCall(); err == bad { \tfmt.Println(err) \treturn \t}  \tfmt.Println(\u0026#34;Life is good\u0026#34;) }  // webCall performs a web operation. func webCall() error { \treturn New(\u0026#34;Bad Request\u0026#34;) }   Go Playground\n它的输出是：Life is good 即 err != bad，但是如果改成使用值语义即把 errorString 的实现改成下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // http://golang.org/src/pkg/errors/errors.go type errorString struct { \ts string }  // http://golang.org/src/pkg/errors/errors.go func (e errorString) Error() string { \treturn e.s }  // http://golang.org/src/pkg/errors/errors.go // New returns an error that formats as the given text. func New(text string) error { \treturn errorString{text} }   那么这段代码就会输出：Bad Request 即 err = bad，因为接口在比较时会比较存储在里面的类型和值，当值和类型都相等的话才相等。如果使用值语义，那么 err 存储的值和类型确实都和 bad 的一样，但是如果使用指针语义的话，那么它们存储的值是指针，而 New 每次返回的 errorString 的地址都不一样所以它们才不会相等。\n6.5 Wrapping Errors 很多 Go 代码都缺乏 log 一致性。\n错误处理和日志记录实际上是同一件事情。\nLog 可能会产生大量的分配，会给堆带来很大的压力。log 很重要，但是我们必须平衡日志中的信号和噪音，因为如果写了日志却从来不会用到，那么就只是在浪费 CPU 周期。所以最好只记录有足够的上下文信息的最少的日志，而且要以同样的方式记录日志而不是随机的。\n如果一段代码要处理错误，它必须决定是否要恢复它，如果不，那么就要关闭程序即调用 panic 或者 os.Exit；如果要恢复，那么它必须把程序恢复到正确的状态并且继续运行。当它返回的时候绝对不会返回另一个 error。\n在调用栈中处理错误的位置越低，恢复的机会就更大。\n如果不处理的话，那么 wrap 这个 error 并返回就可以了。wrap 要做的是添加两种类型的上下文信息，一种是调用栈上下文，一种是用户上下文。\nDave Cheney 的包很符合这种哲学，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how wrapping errors work. package main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/pkg/errors\u0026#34; )  // AppError represents a custom error type. type AppError struct { \tState int }  // Error implements the error interface. func (c *AppError) Error() string { \treturn fmt.Sprintf(\u0026#34;App Error, State: %d\u0026#34;, c.State) }  func main() {  \t// Make the function call and validate the error. \tif err := firstCall(10); err != nil {  \t// Use type as context to determine cause. \tswitch v := errors.Cause(err).(type) { \tcase *AppError:  \t// We got our custom error type. \tfmt.Println(\u0026#34;Custom App Error:\u0026#34;, v.State)  \tdefault:  \t// We did not get any specific error type. \tfmt.Println(\u0026#34;Default Error\u0026#34;) \t}  \t// Display the stack trace for the error. \tfmt.Println(\u0026#34;\\nStack Trace\\n********************************\u0026#34;) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, err) \tfmt.Println(\u0026#34;\\nNo Trace\\n********************************\u0026#34;) \tfmt.Printf(\u0026#34;%v\\n\u0026#34;, err) \t} }  // firstCall makes a call to a second function and wraps any error. func firstCall(i int) error { \tif err := secondCall(i); err != nil { \treturn errors.Wrapf(err, \u0026#34;firstCall-\u0026gt;secondCall(%d)\u0026#34;, i) \t} \treturn nil }  // secondCall makes a call to a third function and wraps any error. func secondCall(i int) error { \tif err := thirdCall(); err != nil { \treturn errors.Wrap(err, \u0026#34;secondCall-\u0026gt;thirdCall()\u0026#34;) \t} \treturn nil }  // thirdCall create an error value we will validate. func thirdCall() error { \treturn \u0026amp;AppError{99} }   Go Playground\n输出是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  Custom App Error: 99  Stack Trace ******************************** App Error, State: 99 secondCall-\u0026gt;thirdCall() main.secondCall \t/tmp/sandbox3687093259/prog.go:60 main.firstCall \t/tmp/sandbox3687093259/prog.go:51 main.main \t/tmp/sandbox3687093259/prog.go:26 runtime.main \t/usr/local/go-faketime/src/runtime/proc.go:250 runtime.goexit \t/usr/local/go-faketime/src/runtime/asm_amd64.s:1571 firstCall-\u0026gt;secondCall(10) main.firstCall \t/tmp/sandbox3687093259/prog.go:52 main.main \t/tmp/sandbox3687093259/prog.go:26 runtime.main \t/usr/local/go-faketime/src/runtime/proc.go:250 runtime.goexit \t/usr/local/go-faketime/src/runtime/asm_amd64.s:1571  No Trace ******************************** firstCall-\u0026gt;secondCall(10): secondCall-\u0026gt;thirdCall(): App Error, State: 99  Program exited.   使用 %+v 打印调用栈上下文和用户上下文，使用 %v 只打印用户上下文。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap6/","summary":"6. Error Handling 6.1 Default Error Values 退出程序的两种方式：os.exit() 和 panic()，如果需要跟踪堆栈信息就用后者。 error 是接口，是解耦的，这很重要，提供了很大","title":"Ultimate Go Programming 笔记——第六章"},{"content":"5. 组合 在 Go 中，组合是最应该关注的事情，重要性甚至超过并发。\n5.1 Grouping Types Go 中没有子类型，也没有子类。\nGo 是按照能够做什么来分组的，而不是是什么。\n嵌入是为了行为，而不是状态，在 Go 中不要创建类似于抽象类的类型，如果两个类有相同的状态，直接复制粘贴它们，而不是给它们创建一个父类，如果这个父类不会真的被用到。\n如果一个抽象类型不是全新的类型，没有它自己独特的含义，就不要创建这个类型，比如说它有了和基类型不一样的方法它就是全新的了（比如 Duration 类型，它实际代表的是纳秒）。\n5.2 Decoupling 先解决具体的问题，然后再思考哪些部分可以解耦，让其能够更好地应对变化。\n先优化正确性，然后再考虑性能。\n函数比方法更加准确不容易出错，因为函数要把需要的数据直接作为参数传进去，而方法是从结构体的字段里取的，当结构体字段发生变化或者没被被初始化可能会导致运行时错误。\n从下到上构建 API，即从最基础的开始，完成之后思考哪些部分可以进行解耦来应对可能的数据变化。\n把借口当作没有值只有行为的变量。\n5.3 Conversion and Assertions v := I.(T) ，如果 I 可以转换成类型 T，那么 V 是原值的拷贝；如果不可以，会恐慌。\nv, ok := I.(T) ，如果 I 可以转换成类型 T，那么 V 是原值的拷贝；如果不可以，ok 是 false ，V 是类型 T 的零值。\n5,4 Interface Pollution Smells:\n The package declares an interface that matches the entire API of its own concrete type.（相当于重复了一遍） The interface is exported but the concrete type is unexported. The factory function returns the interface value with the unexported concrete type value inside. The interface can be removed and nothing changes for the user of the API.（搞了个寂寞） The interface is not decoupling the API from change.  Here are some guidelines around interface pollution: Use an interface:\n  When users of the API need to provide an implementation detail.\n  When API’s have multiple implementations that need to be maintained.\n  When parts of the API that can change have been identified and require decoupling.\n  Question an interface:\n  When its only purpose is for writing testable API’s (write usable API’s first).\n  When it’s not providing support for the API to decouple from change.\n  When it\u0026rsquo;s not clear how the interface makes the code better.\n  5.6 Design Guidelines Design Philosophy:\n Interfaces give programs structure. Interfaces encourage design by composition. Interfaces enable and enforce clean divisions between components.  The standardization of interfaces can set clear and consistent expectations.   Decoupling means reducing the dependencies between components and the types they use.  This leads to correctness, quality and performance.   Interfaces allow you to group concrete types by what they do.  Don\u0026rsquo;t group types by a common DNA but by a common behavior. Everyone can work together when we focus on what we do and not who we are.   Interfaces help your code decouple itself from change.  You must do your best to understand what could change and use interfaces to decouple. Interfaces with more than one method have more than one reason to change. Uncertainty about change is not a license to guess but a directive to STOP and learn more.   You must distinguish between code that:  defends against fraud vs protects against accidents    Validation:\nUse an interface when:\n users of the API need to provide an implementation detail. API’s have multiple implementations they need to maintain internally. parts of the API that can change have been identified and require decoupling.  Don\u0026rsquo;t use an interface:\n for the sake of using an interface. to generalize an algorithm. when users can declare their own interfaces. if it\u0026rsquo;s not clear how the interface makes the code better.  ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap5/","summary":"5. 组合 在 Go 中，组合是最应该关注的事情，重要性甚至超过并发。 5.1 Grouping Types Go 中没有子类型，也没有子类。 Go 是按照能够做什么来分组的，而不是是什么。 嵌入是","title":"Ultimate Go Programming 笔记——第五章"},{"content":"4. 解耦 4.1 方法 一切都是基于数据的，不理解数据就不理解问题，不理解问题就无法写代码。如果问题发生变化，那就意味着数据发生了变化，代码也必须要改变。但我们想要最小化需要改变的代码，这就是解耦的作用。\n解耦是通过行为实现的，行为是我们的设计和架构。但是要从从具体数据入手，不要从行为入手，如果从行为开始，那就是在猜测。正确顺序是首先解决具体的问题，然后努力实现解耦。\n方法的作用是允许数据有自己的行为。和 OOP 语言不同，OOP 中的对象总是有状态和行为，但是 Go 中大部分时候是把这两者分开，函数应该是第一选择，除非它是不合理的或不符合实际的。但问题是数据什么时候应该有行为呢？\n值和指针都可以直接调用使用值和指针声明的方法，Go 会自动调整，但是反复改变语义是很糟糕的。\n怎么选择值接收器和指针接收器？并不是根据是否需要改变数据决定的。其实是要与语义保持一致，数据驱动语义，一旦语义被选定，要么一切都是值，要么一切都是指针。\nGo 中的类型大致可以分为三种：\n内置类型，如数字类型、字符串和布尔，使用值语义，甚至都不应该看到任何指向这些类型的指针。例外：Unmarshal、Marshal。\n引用类型，如映射、切片、接口和通道，同样不应该有指向这些类型的指针，因为它们本来就被设计成可以共享的。例外：Decode、Unmarshal。\n结构体类型，如果不确定就使用指针语义，如果非常确定可以使用值语义就使用值语义。\n结构体中的字段同样应该遵守上述规则，标准库中的代码可以验证这一做法。这也是可以由多人维护一个代码库的关键所在。\n对结构体而言，可以参考真实世界中的规律来决定使用指针语义还是值语义。\n对于不熟悉的类型，参考工厂函数。\n拷贝共享的东西是很危险的，这是对语义法的重大违背。\n如果知道是什么语义在起作用，就知道行为。\n方法其实也是函数，自带语法糖而已。\n解耦会导致间接引用和内存分配，方法让我们有能力赋予数据行为，但是我们仍然需要学习什么时候数据有行为是合理和实用的，这应该是个意外而不是规则。\n4.2 接口 接口让我们获得多态的能力。\n\u0026ldquo;Polymorphism means that you write a certain program and it behaves differently depending on the (concrete) data that it operates on.\u0026rdquo; - Tom Kurtz (inventor of BASIC)\n数据什么时候需要拥有行为？一个好的理由是当我们需要实现多态的时候。\n接口只是定义了行为契约，它不是真实的，没有任何具体的东西。但是赋值的时候它会存储指向具体数据以及数据的类型的指针。\n编译器是爱我们的，它不希望我们写的代码导致完整性问题。\n值类型的方法集只包括使用值接收器定义的方法，而指针类型的方法集同时包括使用值接收器定义以及使用指针接收器定义的方法。但是为什么值类型的方法集不包括使用指针接收器定义的方法呢？\n次要的原因是不是所有的值都可以取地址的（比如说常量），而完整性的意思是百分百正确。\n主要原因是，如果工作在指针语义下，只允许共享，绝对不允许复制指针指向的值。但是有时候在值语义下共享是安全的（比如说 unmarshal）。当我们在接口内存储数据的时候，同样不能违反语义法。\n接口是引用类型，这意味着它使用的是值语义，但是共享数据。\n类型 T 只要实现了所有接口 I 定义的方法就实现了这个接口，不需要像 Java 那样显示地写出来，这也是 Go 约定优于配置的一个表现。\n4.3 嵌入 内部类型的方法可以被提升到外部类型。但这是组合，不是继承。\n如果嵌入的多个类型实现了相同的方法，只有使用了该方法编译器才会报错（歧义），如果没有使用的话就没任何问题。\n外部类型的方法会覆盖内部类型的同名方法。\n4.4 导出 Go 的约定之一：包的名字要和文件夹的名字一样，包是最小的编译单元。\nGo 的导不导出并不是 public 和 private，public 和 private 是关于数据的，导出是关于标识符的，Go 的编译器是可以访问所有内容的，导出的作用是让我们 coder 可以直接访问。\n类型级别封装中一个有意思的现象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Package users provides support for user management. package users  // user represents information about a user. type user struct { \tName string \tID int }  // Manager represents information about a manager. type Manager struct { \tTitle string  \tuser }   在 users 包以外是可以访问 u.Name 和 u.ID 的，即使 user 类型是未导出的。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap4/","summary":"4. 解耦 4.1 方法 一切都是基于数据的，不理解数据就不理解问题，不理解问题就无法写代码。如果问题发生变化，那就意味着数据发生了变化，代码也必须要改变","title":"Ultimate Go Programming 笔记——第四章"},{"content":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。\n如果数据变了，那么问题也就变了，如果问题变了，那么要使用的算法也就变了，有时候会导致连带变化，这时候就要关注如何把代码和数据的变化分离开来，以便将这些连带变化降到最低。如果在抽象的基础上再建立抽象，那就和正确性和可读性走远了，甚至会影响理解代码的心智模型的能力。我们需要解耦的平衡，要用薄的解耦层来应对变化。如果写代码的时候不确定要使用的数据，这时候不应该猜测，这是停下来的指示，转去思考摆在自己面前的数据转换是什么，不必知道所有的数据，但是只对自己有信心的部分编码，不要在今天写下明天的 bug。\n3.2 数组 缓存层次：\n酷睿 i7 系列 CPU 延迟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  3GHz(3 clock cycles/ns） * 4 instructions per cycle = 12 instructions per ns!  1 ns ............. 1 ns .............. 12 instructions (one） 1 µs .......... 1000 ns .......... 12,000 instructions (thousand） 1 ms ..... 1,000,000 ns ...... 12,000,000 instructions (million） 1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions (billion）  L1 - 64KB Cache (Per Core） \t4 cycles of latency at 1.3 ns \tStalls for 16 instructions  L2 - 256KB Cache (Per Core） \t12 cycles of latency at 4 ns \tStalls for 48 instructions  L3 - 8MB Cache \t40 cycles of latency at 13.3 ns \tStalls for 160 instructions  Main Memory \t100 cycle of latency at 33.3 ns \tStalled for 400 instructions   访问主存太慢了，所以需要缓存。访问主存的一个字节会导致读取和缓存整个缓存线（cache line），向缓存线中写一个字节也会导致写整个缓存线，一个缓存线的大小通常是 32 或 64 字节。\n可预测的访问模式也很重要，这样预取器（prefetcher）可以提前把需要的数据读到缓存里，所以说预取器喜欢数组，硬件喜欢数组，数组（在 Go 中其实是切片）真的是当今硬件中最重要的数据结构。\n比如说实践中通常采用线性数组遍历（比如说一行一行访问而不是一列一列访问）。\n缓存的缺失也可能导致快表（TLB）的缺失，这使得可预测的访问模式更加重要，它不仅有助于缓存线，还有助于确保 TLB 也是正确的缓存，这样对内存的访问才是尽可能快的。当今的性能并不是时钟有多快，而是如何有效地将数据在需要之前就把它送进处理器。\nfor i, v := range arr 创建数组本身的拷贝然后再遍历，而且 v 也是拷贝数组中元素的拷贝，但它的地址是不变的，即它是复用的。不要对数组的指针进行遍历，这样语义就太混乱了。\n3.3 切片 声明和长度和引用类型 切片和字符串类似，也是引用类型（这个视频把字符串、切片、映射、通道、接口和函数类型称作引用类型，因为它们的数据结构中包含指针，而且除了字符串的零值是空值外它们的零值都是 nil），它有三个字段分别是指向数组的指针、长度和容量。\n长度是从指针位置可以访问到的元素总数，容量是存在于指针指向的数组中的元素总数，容量可以比长度大反之则不行。\n引用类型使用的是值语义，目的是可以直接传值来共享数据并且开销很小且固定，因为它里面包含的是指向真正数据的指针，在复制时复制指针就可以了。\n追加 一个有趣的现象是，使用 var s1 []string 声明的切片是 nil 切片，而使用 s2 := []string{} 声明的切片是空切片，它们两个的意义并不一样，虽然它们的长度和容量都为0，但是空切片中的指针是指向空结构体的而 nil 切片中的指针也是 nil。这种差异可以用于判断返回值是否出错，如果返回 nil 可以认为是出错了，如果是空切片的话可以认为没有出错只不过返回的数据为空而已。\n在使用 append 函数时如果切片的长度和容量一样即满了则创建新的底层数组并且扩容，当需要的容量超过原切片容量的两倍时，会使用需要的容量作为新容量；当切片长度小于 1024 时容量翻倍，大于 1024 时会反复增加 25% 直到新容量超过所需要的容量。需要注意，切片使用值语义，在使用 append 时传递的是切片的拷贝，当然这个拷贝和原切片共享底层数组，所以使用 append 后最好把返回值赋给原切片，以免出现内存泄漏，即：\n1 2  s = append(s, value) s1 = append(s, value) // 不要这样   如果知道切片的长度的话就直接在创建时指定，这样就不用使用 append 了。\n切片的切片 切片值可以在栈上，底层数组才需要在堆上。\narr[a:b] 的意思是取切片或数组 arr 从 a 到 b 不包括 b 的部分，即前闭后开区间，所以最好使用长度来取切片即 arr[a:a+len]，这样比较不容易出错。\n取切片也存在副作用，因为切片的切片和原切片共享底层数组，所以如果改变其中一个切片两者共同索引区间内的元素那么另一个切片也会受到影响；另外一方面，如果子切片的容量比长度大，那么对其调用 append 时会直接改变它尾部后面的那个元素从而影响原切片，但是可以使用三个索引创建切片即 arr[a : b : b] 来解决这个问题，最后一个索引用来指定容量，这样这个切片的长度和容量就是一样的，如果再对其调用 append 函数则会创建新的底层数组。\n有时候需要使用 copy(dst, src) 来复制切片。\n切片和引用 如果有指向切片中某个元素的指针，然后这个切片扩容后改变了底层数组，导致原来的指针失效并且造成内存泄漏，这是非常烦人的 bug，所以对切片调用 append 时一定要注意检查是否会创建新的底层数组，如果会的话一定要再三检查是否有副作用。\nrange 机制 切片的 range 和数组一样也会创建切片的拷贝，如果在遍历过程中改变了原切片，使用值语义是不受影响的，但是使用指针语义会受影响：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Using the value semantic form of the for range. friends := []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for _, v := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, v) }  // Using the pointer semantic form of the for range. friends = []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for i := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, friends[i]) }  // Output: // v[Betty] // v[Charley] // v[Doug] // v[Edward] // v[Annie] // v[Betty] // panic: runtime error: index out of range [2] with length 2  // goroutine 1 [running]: // main.main() // /tmp/sandbox1154993090/prog.go:22 +0x2ae  // Program exited.   3.4 映射 映射的零值不可用，必须 make 或者使用字面量声明才可以用。\n映射使用值语义，它的值是原始值的拷贝而不是指针。\n映射的 range 循环得到的也是映射中键和值的拷贝。\n可以使用 delete(mp, key) 删除映射中的键，如果使用映射当作缓存则必须删除键来避免内存泄漏。\n映射的键必须是可哈希的，即可以出现在 if 中。\n映射的键是无序的，如果需要有序键的话要手动排序。\n映射也是引用类型，传递给函数有副作用。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap3/","summary":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。 如果数据变了，那么问题也就变了，如果问","title":"Ultimate Go Programming 笔记——第三章"},{"content":"如图：\n","permalink":"https://tiandiyijian.top/posts/goland%E5%92%8Cidea%E4%BD%BF%E7%94%A8cmder/","summary":"如图：","title":"Goland和IDEA使用cmder"},{"content":"1 2  $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系   这两行命令执行过之后会在当前 conda 环境的 bin 目录中生成这两个文件：\n1 2  x86_64-conda-linux-gnu-gcc x86_64-conda-linux-gnu-g++   为了方便使用可以用软链创建两个文件：\n1 2  $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-gcc ~/miniconda3(your conda path)/envs/(env)/bin/gcc $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-g++ ~/miniconda3(your conda path)/envs/(env)/bin/g++   然后重启一下环境应该就生效了。\n参考：\n如何改变anaconda 的 gcc 版本？ - 徐智明的回答 - 知乎 \n","permalink":"https://tiandiyijian.top/posts/conda%E5%AE%89%E8%A3%85gcc%E5%92%8Cg++/","summary":"1 2 $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系 这两行命令执行过之后会","title":"Conda安装gcc和g++"},{"content":"2.语言机制 2.1变量 Type is everything, type is life!\n类型提供了两个信息：内存大小和它的表示方法。\n如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明它。\n为了完整性（integrity），Go 没有 casting 机制，所以需要显示类型转换。\n2.2结构体 大小 如果要理解成本，必须要理解内存分配。\nCPU 访问内存是以字长（比如 32 位机器是 4 字节）为单位的，为了方便 CPU 访问即提高内存读写效率，结构体需要做内存对齐。\n内存对齐主要遵循下面三个原则：\n 结构体变量的起始地址能够被其最宽的成员大小整除 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节  Go语言中空结构体的大小为0，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的，但是空结构体有一个特例，那就是当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放），所以当struct{}作为结构体成员中最后一个字段时，要填充额外的内存保证安全。\n如果真的很需要做内存优化的话，可以把结构体中的字段按从大到小的顺序排列，但是最好还是按照语义顺序来，因为可读性才是最重要的。\n类型转换 字段完全相同（顺序也要相同）的命名类型之间赋值需要做显示转换，匿名类型可以直接赋值，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // example represents a type with different fields. type example struct { \tflag bool \tcounter int16 \tpi float32 }  type example2 struct { \tflag bool \tcounter int16 \tpi float32 }  func main() {  \t// Declare a variable of an anonymous type and init \t// using a struct literal. \te := struct { \tflag bool \tcounter int16 \tpi float32 \t}{ \tflag: true, \tcounter: 10, \tpi: 3.141592, \t}  \t// Create a value of type example. \tvar ex example \tvar ex2 example2  \t// ex = ex2 // cannot use ex2 (variable of type example2) as type example in assignment \tex = example(ex2)  \t// Assign the value of the unnamed struct type \t// to the named struct type value. \tex = e  \t// Display the values. \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, ex) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, e) }   2.3指针 传值 Go 只有传值，好处是提供了隔离性，局部的改动不会影响全局。坏处是可能影响性能，因为一份数据可能在程序中有多个拷贝，而且如果相同时改变这些拷贝有一定难度。\n共享数据 如果需要共享数据的话就需要传指针了，但是指针也是值，是地址的值而不是引用，取决于不同的操作系统一个指针会占用4字节或者8字节的空间，在传指针的时候会发生一次地址值的拷贝。另外，指针是字面量类型，它是有类型的，因为有了类型编译器才知道一种特定的指针可以做什么操作，Type is life！\n逃逸分析 栈能带来的好处不仅是 isolation 和 immutability 以及减少 side effects，还能在很多情况下带来更好的性能，因为它是自清理的，一个函数返回之后它的栈已经完全没用了，它上层的函数再进行函数调用时可以直接覆盖，不需要垃圾收集器。\n所以，如果要共享一个变量的话，就必须把它分配在堆上，然后返回它的指针即地址值。\n为了更好的可读性，一定要区分开什么时候使用值语义，什么时候使用指针语义。在构造过程中不要使用指针语义，如果需要共享它就在 return 时使用 \u0026amp; 操作符，这样一眼就能看出它是否逃逸到堆中。如果变量的生命从指针开始，那么就失去可读性了，因为它并不能告诉你它在内存中的位置。\n像这样的代码就非常折磨。\n另外，当编译器不知道某个变量的大小（比如切片）时，那么也会在堆上分配它的内存。栈并不是动态的，在编译期就已经确定。\n如果变量太大时，也会把它分配在堆上。\n栈增长 当栈空间（2K）满时，会扩容25%，然后把之前的内容拷贝到新栈上去，这意味这栈里面变量的内存地址是有可能发生改变的。既然栈的地址是可能发生变化的，在 Go 中，栈内存在 goroutine 之间是不能共享的。\n垃圾回收 影响性能的因素（1.3节）\n 网络和磁盘 IO 延迟 内存分配和垃圾回收 访问数据的方式和效率 算法  小堆、回收频率、时间短之间的平衡\n2.4常数 常数只在编译期存在，最少拥有256比特的精度。下面的程序可以通过编译，但是如果要使用 bigger 这个变量就会在编译期报溢出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how constants do have a parallel type system. package main  import \u0026#34;fmt\u0026#34;  const ( \t// Max integer value on 64 bit architecture. \tmaxInt = 9223372036854775807  \t// Much larger value than int64. \tbigger = 9223372036854775808543522345  \t// Will NOT compile \t// biggerInt int64 = 9223372036854775808543522345 )  func main() { \tfmt.Println(\u0026#34;Will Compile\u0026#34;) \t//fmt.Println(maxInt, bigger) }   常数是没有类型的，可以把它的类型理解为另一种东西——种类 kind，编译器会根据上下文做隐式转换（在函数传参的时候非常方便，不用做类型转换直接传一个字面量就行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how to declare constants and their // implementation in Go. package main  func main() {  \t// Constants live within the compiler. \t// They have a parallel type system. \t// Compiler can perform implicit conversions of untyped constants.  \t// Untyped Constants. \tconst ui = 12345 // kind: integer \tconst uf = 3.141592 // kind: floating-point  \t// Typed Constants still use the constant type system but their precision \t// is restricted. \tconst ti int = 12345 // type: int \tconst tf float64 = 3.141592 // type: float64  \t// ./constants.go:XX: constant 1000 overflows uint8 \t// const myUint8 uint8 = 1000  \t// Constant arithmetic supports different kinds. \t// Kind Promotion is used to determine kind in these scenarios.  \t// Variable answer will of type float64. \tvar answer = 3 * 0.333 // KindFloat(3) * KindFloat(0.333)  \t// Constant third will be of kind floating point. \tconst third = 1 / 3.0 // KindFloat(1) / KindFloat(3.0)  \t// Constant zero will be of kind integer. \tconst zero = 1 / 3 // KindInt(1) / KindInt(3)  \t// This is an example of constant arithmetic between typed and \t// untyped constants. Must have like types to perform math. \tconst one int8 = 1 \tconst two = 2 * one // int8(2) * int8(1) }   声明常量时可以使用 iota，它表示行数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how iota works. package main  import \u0026#34;fmt\u0026#34;  func main() {  \tconst ( \tA1 = iota // 0 : Start at 0 \tB1 = iota // 1 : Increment by 1 \tC1 = iota // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;1:\u0026#34;, A1, B1, C1)  \tconst ( \tA2 = iota // 0 : Start at 0 \tB2 // 1 : Increment by 1 \tC2 // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;2:\u0026#34;, A2, B2, C2)  \tconst ( \tA3 = iota + 1 // 1 : Start at 0 + 1 \tB3 // 2 : Increment by 1 \tC3 // 3 : Increment by 1 \t)  \tfmt.Println(\u0026#34;3:\u0026#34;, A3, B3, C3)  \tconst ( \tLdate = 1 \u0026lt;\u0026lt; iota // 1 : Shift 1 to the left 0. 0000 0001 \tLtime // 2 : Shift 1 to the left 1. 0000 0010 \tLmicroseconds // 4 : Shift 1 to the left 2. 0000 0100 \tLlongfile // 8 : Shift 1 to the left 3. 0000 1000 \tLshortfile // 16 : Shift 1 to the left 4. 0001 0000 \tLUTC // 32 : Shift 1 to the left 5. 0010 0000 \t)  \tfmt.Println(\u0026#34;Log:\u0026#34;, Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC) }   ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap2/","summary":"2.语言机制 2.1变量 Type is everything, type is life! 类型提供了两个信息：内存大小和它的表示方法。 如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明","title":"Ultimate Go Programming 笔记——第二章"},{"content":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现很多东西还是得记录一下的，脑子真的容易遗忘；二是意识到想要提升能力，还是需要坚持学习，坚持记录。\n现在彻底决定毕业后搞开发不搞算法了，选择了 Go 语言，以前也听说过 hugo 这个生成器，就是用 Go 写的，遂决定尝试一下，还是遇到一些坑的，记录一下。\n添加搜索 因为搜索这个功能需要 index.json 这个文件，但默认是不生成的，需要在配置里打开：\n1 2 3 4 5 6  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON   另外，在生成的时候要加 -D 参数才可以，要不然不生成 /search这个路径对应的文件夹，访问的话会是 404 页面。官网查了一下这个参数的作用：\n1  -D, --buildDrafts include content marked as draft   看不太懂。。\n添加分类和标签 增加归档和搜索页面只需要创建 archives.md 和 search.md 这两个文件就行了，本来我还以为分类和标签也是这样，但是怎么试都不行，后来发现在配置文件里加上这几句就行了：\n1 2 3 4  taxonomies:  category: Categories  tag: Tags  series: series   上面这两个就是我碰见的耗时最多去解决的问题了，感觉 hugo 相关的内容在网上还不是很多，分享一下我的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194  baseURL: \u0026#39;https://tiandiyijian.top\u0026#39; languageCode: \u0026#39;en-us\u0026#39; title: 天地一键 paginate: 10 theme: PaperMod  publishDir: docs enableInlineShortcodes: true enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true  hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启  buildDrafts: false buildFuture: false buildExpired: false  #googleAnalytics: UA-123-45 # 谷歌统计 # Copyright: Sulv  paginate: 15 # 首页每页显示的文章数  minify:  disableXML: true  # minifyOutput: true  permalinks:  post: \u0026#34;/:title/\u0026#34;  # post: \u0026#34;/:year/:month/:day/:title/\u0026#34;  params:  env: production # to enable google analytics, opengraph, twitter-cards and schema.  title: ExampleSite  description: \u0026#34;ExampleSite description\u0026#34;  keywords: [Blog, Portfolio, PaperMod]  author: Me  # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors  # images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;]  DateFormat: \u0026#34;January 2, 2006\u0026#34;  defaultTheme: auto # dark, light  disableThemeToggle: false   ShowReadingTime: true  ShowShareButtons: true  ShowPostNavLinks: true  ShowBreadCrumbs: true  ShowCodeCopyButtons: false  disableSpecial1stPost: false  disableScrollToTop: false  comments: false  hidemeta: false  hideSummary: false  showtoc: true # 开启目录  tocopen: false   assets:  # disableHLJS: true # to disable highlight.js  # disableFingerprinting: true  favicon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon16x16: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon32x32: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  apple_touch_icon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  safari_pinned_tab: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;   # profile-mode  profileMode:  enabled: false # needs to be explicitly set  title: Haha  subtitle: \u0026#34;This is subtitle\u0026#34;  imageUrl: \u0026#34;#\u0026#34;  imageWidth: 120  imageHeight: 120  imageTitle: my image  buttons:  - name: Posts  url: posts  - name: Tags  url: tags   # home-info mode  homeInfoParams:  Title: \u0026#34;Hi there \\U0001F44B\u0026#34;  Content: Welcome to my blog   socialIcons:  - name: github  url: \u0026#34;https://github.com/tiandiyijian\u0026#34;   analytics:  google:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  bing:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  yandex:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;   cover:  hidden: true # hide everywhere but not in structured data  hiddenInList: true # hide on list pages and home  hiddenInSingle: true # hide on single page   editPost:  URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34;  Text: \u0026#34;Suggest Changes\u0026#34; # edit text  appendFilePath: true # to append file path to Edit link   # for search  # https://fusejs.io/api/options.html  fuseOpts:  isCaseSensitive: false  shouldSort: true  location: 0  distance: 1000  threshold: 0.4  minMatchCharLength: 0  keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;]   menu:  main:  - identifier: search  name: Search  url: /search/  weight: 5  - identifier: categories  name: Categories  url: /categories/  weight: 10  - identifier: tags  name: Tags  url: /tags/  weight: 20  - identifier: archives  name: Archive  url: /archives/  weight: 30   taxonomies:  category: Categories  tag: Tags  series: series  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON  markup:  goldmark:  renderer:  unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话  highlight:  # anchorLineNos: true  codeFences: true  guessSyntax: true  lineNos: true  # noClasses: false  # style: monokai  style: darcula   codeFences: true # 代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。  # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。  # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。  # lineNoStart：行号从编号几开始，一般从 1 开始。  # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true.  # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true.  # noClasses：使用 class 标签，而不是内嵌的内联样式  privacy:  vimeo:  disabled: false  simple: true   twitter:  disabled: false  enableDNT: true  simple: true   instagram:  disabled: false  simple: true   youtube:  disabled: false  privacyEnhanced: true  services:  instagram:  disableInlineCSS: true  twitter:  disableInlineCSS: true   我也还没全部搞懂上面的配置项都是啥意思，以后用的到时候再慢慢研究吧。有一说一，hugo 的速度真的快。\n参考：\n【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://tiandiyijian.top/posts/hugo%E8%B8%A9%E5%9D%91/","summary":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现","title":"Hugo踩坑"}]