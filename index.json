[{"content":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。\n如果数据变了，那么问题也就变了，如果问题变了，那么要使用的算法也就变了，有时候会导致连带变化，这时候就要关注如何把代码和数据的变化分离开来，以便将这些连带变化降到最低。如果在抽象的基础上再建立抽象，那就和正确性和可读性走远了，甚至会影响理解代码的心智模型的能力。我们需要解耦的平衡，要用薄的解耦层来应对变化。如果写代码的时候不确定要使用的数据，这时候不应该猜测，这是停下来的指示，转去思考摆在自己面前的数据转换是什么，不必知道所有的数据，但是只对自己有信心的部分编码，不要在今天写下明天的 bug。\n3.2 数组 缓存层次：\n酷睿 i7 系列 CPU 延迟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  3GHz(3 clock cycles/ns） * 4 instructions per cycle = 12 instructions per ns!  1 ns ............. 1 ns .............. 12 instructions (one） 1 µs .......... 1000 ns .......... 12,000 instructions (thousand） 1 ms ..... 1,000,000 ns ...... 12,000,000 instructions (million） 1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions (billion）  L1 - 64KB Cache (Per Core） \t4 cycles of latency at 1.3 ns \tStalls for 16 instructions  L2 - 256KB Cache (Per Core） \t12 cycles of latency at 4 ns \tStalls for 48 instructions  L3 - 8MB Cache \t40 cycles of latency at 13.3 ns \tStalls for 160 instructions  Main Memory \t100 cycle of latency at 33.3 ns \tStalled for 400 instructions   访问主存太慢了，所以需要缓存。访问主存的一个字节会导致读取和缓存整个缓存线（cache line），向缓存线中写一个字节也会导致写整个缓存线，一个缓存线的大小通常是 32 或 64 字节。\n可预测的访问模式也很重要，这样预取器（prefetcher）可以提前把需要的数据读到缓存里，所以说预取器喜欢数组，硬件喜欢数组，数组（在 Go 中其实是切片）真的是当今硬件中最重要的数据结构。\n比如说实践中通常采用线性数组遍历（比如说一行一行访问而不是一列一列访问）。\n缓存的缺失也可能导致快表（TLB）的缺失，这使得可预测的访问模式更加重要，它不仅有助于缓存线，还有助于确保 TLB 也是正确的缓存，这样对内存的访问才是尽可能快的。当今的性能并不是时钟有多快，而是如何有效地将数据在需要之前就把它送进处理器。\nfor i, v := range arr 创建数组本身的拷贝然后再遍历，而且 v 也是拷贝数组中元素的拷贝，但它的地址是不变的，即它是复用的。不要对数组的指针进行遍历，这样语义就太混乱了。\n3.3 切片 声明和长度和引用类型 切片和字符串类似，也是引用类型（这个视频把字符串、切片、映射、通道、接口和函数类型称作引用类型，因为它们的数据结构中包含指针，而且除了字符串的零值是空值外它们的零值都是 nil），它有三个字段分别是指向数组的指针、长度和容量。\n长度是从指针位置可以访问到的元素总数，容量是存在于指针指向的数组中的元素总数，容量可以比长度大反之则不行。\n引用类型使用的是值语义，目的是可以直接传值来共享数据并且开销很小且固定，因为它里面包含的是指向真正数据的指针，在复制时复制指针就可以了。\n追加 一个有趣的现象是，使用 var s1 []string 声明的切片是 nil 切片，而使用 s2 := []string{} 声明的切片是空切片，它们两个的意义并不一样，虽然它们的长度和容量都为0，但是空切片中的指针是指向空结构体的而 nil 切片中的指针也是 nil。这种差异可以用于判断返回值是否出错，如果返回 nil 可以认为是出错了，如果是空切片的话可以认为没有出错只不过返回的数据为空而已。\n在使用 append 函数时如果切片的长度和容量一样即满了则创建新的底层数组并且扩容，当需要的容量超过原切片容量的两倍时，会使用需要的容量作为新容量；当切片长度小于 1024 时容量翻倍，大于 1024 时会反复增加 25% 直到新容量超过所需要的容量。需要注意，切片使用值语义，在使用 append 时传递的是切片的拷贝，当然这个拷贝和原切片共享底层数组，所以使用 append 后最好把返回值赋给原切片，以免出现内存泄漏，即：\n1 2  s = append(s, value) s1 = append(s, value) // 不要这样   如果知道切片的长度的话就直接在创建时指定，这样就不用使用 append 了。\n切片的切片 切片值可以在栈上，底层数组才需要在堆上。\narr[a:b] 的意思是取切片或数组 arr 从 a 到 b 不包括 b 的部分，即前闭后开区间，所以最好使用长度来取切片即 arr[a:a+len]，这样比较不容易出错。\n取切片也存在副作用，因为切片的切片和原切片共享底层数组，所以如果改变其中一个切片两者共同索引区间内的元素那么另一个切片也会受到影响；另外一方面，如果子切片的容量比长度大，那么对其调用 append 时会直接改变它尾部后面的那个元素从而影响原切片，但是可以使用三个索引创建切片即 arr[a🅱️b] 来解决这个问题，最后一个索引用来指定容量，这样这个切片的长度和容量就是一样的，如果再对其调用 append 函数则会创建新的底层数组。\n有时候需要使用 copy(dst, src) 来复制切片。\n切片和引用 如果有指向切片中某个元素的指针，然后这个切片扩容后改变了底层数组，导致原来的指针失效并且造成内存泄漏，这是非常烦人的 bug，所以对切片调用 append 时一定要注意检查是否会创建新的底层数组，如果会的话一定要再三检查是否有副作用。\nrange 机制 切片的 range 和数组一样也会创建切片的拷贝，如果在遍历过程中改变了原切片，使用值语义是不受影响的，但是使用指针语义会受影响：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // Using the value semantic form of the for range. friends := []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for _, v := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, v) }  // Using the pointer semantic form of the for range. friends = []string{\u0026#34;Annie\u0026#34;, \u0026#34;Betty\u0026#34;, \u0026#34;Charley\u0026#34;, \u0026#34;Doug\u0026#34;, \u0026#34;Edward\u0026#34;} for i := range friends { friends = friends[:2] fmt.Printf(\u0026#34;v[%s]\\n\u0026#34;, friends[i]) }  // Output: // v[Betty] // v[Charley] // v[Doug] // v[Edward] // v[Annie] // v[Betty] // panic: runtime error: index out of range [2] with length 2  // goroutine 1 [running]: // main.main() // /tmp/sandbox1154993090/prog.go:22 +0x2ae  // Program exited.   3.4 映射 映射的零值不可用，必须 make 或者使用字面量声明才可以用。\n映射使用值语义，它的值是原始值的拷贝而不是指针。\n映射的 range 循环得到的也是映射中键和值的拷贝。\n可以使用 delete(mp, key) 删除映射中的键，如果使用映射当作缓存则必须删除键来避免内存泄漏。\n映射的键必须是可哈希的，即可以出现在 if 中。\n映射的键是无序的，如果需要有序键的话要手动排序。\n映射也是引用类型，传递给函数有副作用。\n","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap3/","summary":"3.数据结构 3.1 面向数据设计 任何想要解决的问题都是数据问题，如果不理解要使用的数据就不理解要解决的问题。 如果数据变了，那么问题也就变了，如果问","title":"Ultimate Go Programming 笔记——第三章"},{"content":"如图：\n","permalink":"https://tiandiyijian.top/posts/goland%E5%92%8Cidea%E4%BD%BF%E7%94%A8cmder/","summary":"如图：","title":"Goland和IDEA使用cmder"},{"content":"1 2  $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系   这两行命令执行过之后会在当前 conda 环境的 bin 目录中生成这两个文件：\n1 2  x86_64-conda-linux-gnu-gcc x86_64-conda-linux-gnu-g++   为了方便使用可以用软链创建两个文件：\n1 2  $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-gcc ~/miniconda3(your conda path)/envs/(env)/bin/gcc $ ln -s ~/miniconda3(your conda path)/envs/(env)/bin/x86_64-conda-linux-gnu-g++ ~/miniconda3(your conda path)/envs/(env)/bin/g++   然后重启一下环境应该就生效了。\n参考：\n如何改变anaconda 的 gcc 版本？ - 徐智明的回答 - 知乎 \n","permalink":"https://tiandiyijian.top/posts/conda%E5%AE%89%E8%A3%85gcc%E5%92%8Cg++/","summary":"1 2 $ conda install gcc_linux-64 # 安装gcc, 可以加等于号指定版本，下同 $ conda install gxx_linux-64 # 安装g++, 直接执行这个也会安装上面那个, 应该是依赖关系 这两行命令执行过之后会","title":"Conda安装gcc和g++"},{"content":"2.语言机制 2.1变量 Type is everything, type is life!\n类型提供了两个信息：内存大小和它的表示方法。\n如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明它。\n为了完整性（integrity），Go 没有 casting 机制，所以需要显示类型转换。\n2.2结构体 大小 如果要理解成本，必须要理解内存分配。\nCPU 访问内存是以字长（比如 32 位机器是 4 字节）为单位的，为了方便 CPU 访问即提高内存读写效率，结构体需要做内存对齐。\n内存对齐主要遵循下面三个原则：\n 结构体变量的起始地址能够被其最宽的成员大小整除 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节  Go语言中空结构体的大小为0，如果一个结构体中包含空结构体类型的字段时，通常是不需要进行内存对齐的，但是空结构体有一个特例，那就是当 struct{} 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放），所以当struct{}作为结构体成员中最后一个字段时，要填充额外的内存保证安全。\n如果真的很需要做内存优化的话，可以把结构体中的字段按从大到小的顺序排列，但是最好还是按照语义顺序来，因为可读性才是最重要的。\n类型转换 字段完全相同（顺序也要相同）的命名类型之间赋值需要做显示转换，匿名类型可以直接赋值，如下例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // example represents a type with different fields. type example struct { \tflag bool \tcounter int16 \tpi float32 }  type example2 struct { \tflag bool \tcounter int16 \tpi float32 }  func main() {  \t// Declare a variable of an anonymous type and init \t// using a struct literal. \te := struct { \tflag bool \tcounter int16 \tpi float32 \t}{ \tflag: true, \tcounter: 10, \tpi: 3.141592, \t}  \t// Create a value of type example. \tvar ex example \tvar ex2 example2  \t// ex = ex2 // cannot use ex2 (variable of type example2) as type example in assignment \tex = example(ex2)  \t// Assign the value of the unnamed struct type \t// to the named struct type value. \tex = e  \t// Display the values. \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, ex) \tfmt.Printf(\u0026#34;%+v\\n\u0026#34;, e) }   2.3指针 传值 Go 只有传值，好处是提供了隔离性，局部的改动不会影响全局。坏处是可能影响性能，因为一份数据可能在程序中有多个拷贝，而且如果相同时改变这些拷贝有一定难度。\n共享数据 如果需要共享数据的话就需要传指针了，但是指针也是值，是地址的值而不是引用，取决于不同的操作系统一个指针会占用4字节或者8字节的空间，在传指针的时候会发生一次地址值的拷贝。另外，指针是字面量类型，它是有类型的，因为有了类型编译器才知道一种特定的指针可以做什么操作，Type is life！\n逃逸分析 栈能带来的好处不仅是 isolation 和 immutability 以及减少 side effects，还能在很多情况下带来更好的性能，因为它是自清理的，一个函数返回之后它的栈已经完全没用了，它上层的函数再进行函数调用时可以直接覆盖，不需要垃圾收集器。\n所以，如果要共享一个变量的话，就必须把它分配在堆上，然后返回它的指针即地址值。\n为了更好的可读性，一定要区分开什么时候使用值语义，什么时候使用指针语义。在构造过程中不要使用指针语义，如果需要共享它就在 return 时使用 \u0026amp; 操作符，这样一眼就能看出它是否逃逸到堆中。如果变量的生命从指针开始，那么就失去可读性了，因为它并不能告诉你它在内存中的位置。\n像这样的代码就非常折磨。\n另外，当编译器不知道某个变量的大小（比如切片）时，那么也会在堆上分配它的内存。栈并不是动态的，在编译期就已经确定。\n如果变量太大时，也会把它分配在堆上。\n栈增长 当栈空间（2K）满时，会扩容25%，然后把之前的内容拷贝到新栈上去，这意味这栈里面变量的内存地址是有可能发生改变的。既然栈的地址是可能发生变化的，在 Go 中，栈内存在 goroutine 之间是不能共享的。\n垃圾回收 影响性能的因素（1.3节）\n 网络和磁盘 IO 延迟 内存分配和垃圾回收 访问数据的方式和效率 算法  小堆、回收频率、时间短之间的平衡\n2.4常数 常数只在编译期存在，最少拥有256比特的精度。下面的程序可以通过编译，但是如果要使用 bigger 这个变量就会在编译期报溢出错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how constants do have a parallel type system. package main  import \u0026#34;fmt\u0026#34;  const ( \t// Max integer value on 64 bit architecture. \tmaxInt = 9223372036854775807  \t// Much larger value than int64. \tbigger = 9223372036854775808543522345  \t// Will NOT compile \t// biggerInt int64 = 9223372036854775808543522345 )  func main() { \tfmt.Println(\u0026#34;Will Compile\u0026#34;) \t//fmt.Println(maxInt, bigger) }   常数是没有类型的，可以把它的类型理解为另一种东西——种类 kind，编译器会根据上下文做隐式转换（在函数传参的时候非常方便，不用做类型转换直接传一个字面量就行）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how to declare constants and their // implementation in Go. package main  func main() {  \t// Constants live within the compiler. \t// They have a parallel type system. \t// Compiler can perform implicit conversions of untyped constants.  \t// Untyped Constants. \tconst ui = 12345 // kind: integer \tconst uf = 3.141592 // kind: floating-point  \t// Typed Constants still use the constant type system but their precision \t// is restricted. \tconst ti int = 12345 // type: int \tconst tf float64 = 3.141592 // type: float64  \t// ./constants.go:XX: constant 1000 overflows uint8 \t// const myUint8 uint8 = 1000  \t// Constant arithmetic supports different kinds. \t// Kind Promotion is used to determine kind in these scenarios.  \t// Variable answer will of type float64. \tvar answer = 3 * 0.333 // KindFloat(3) * KindFloat(0.333)  \t// Constant third will be of kind floating point. \tconst third = 1 / 3.0 // KindFloat(1) / KindFloat(3.0)  \t// Constant zero will be of kind integer. \tconst zero = 1 / 3 // KindInt(1) / KindInt(3)  \t// This is an example of constant arithmetic between typed and \t// untyped constants. Must have like types to perform math. \tconst one int8 = 1 \tconst two = 2 * one // int8(2) * int8(1) }   声明常量时可以使用 iota，它表示行数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  // All material is licensed under the Apache License Version 2.0, January 2004 // http://www.apache.org/licenses/LICENSE-2.0  // Sample program to show how iota works. package main  import \u0026#34;fmt\u0026#34;  func main() {  \tconst ( \tA1 = iota // 0 : Start at 0 \tB1 = iota // 1 : Increment by 1 \tC1 = iota // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;1:\u0026#34;, A1, B1, C1)  \tconst ( \tA2 = iota // 0 : Start at 0 \tB2 // 1 : Increment by 1 \tC2 // 2 : Increment by 1 \t)  \tfmt.Println(\u0026#34;2:\u0026#34;, A2, B2, C2)  \tconst ( \tA3 = iota + 1 // 1 : Start at 0 + 1 \tB3 // 2 : Increment by 1 \tC3 // 3 : Increment by 1 \t)  \tfmt.Println(\u0026#34;3:\u0026#34;, A3, B3, C3)  \tconst ( \tLdate = 1 \u0026lt;\u0026lt; iota // 1 : Shift 1 to the left 0. 0000 0001 \tLtime // 2 : Shift 1 to the left 1. 0000 0010 \tLmicroseconds // 4 : Shift 1 to the left 2. 0000 0100 \tLlongfile // 8 : Shift 1 to the left 3. 0000 1000 \tLshortfile // 16 : Shift 1 to the left 4. 0001 0000 \tLUTC // 32 : Shift 1 to the left 5. 0010 0000 \t)  \tfmt.Println(\u0026#34;Log:\u0026#34;, Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC) }   ","permalink":"https://tiandiyijian.top/posts/ultimate-go-programming-chap2/","summary":"2.语言机制 2.1变量 Type is everything, type is life! 类型提供了两个信息：内存大小和它的表示方法。 如果要使用一种类型的零值的话，为了保持一致性，最好使用 var 来声明","title":"Ultimate Go Programming 笔记——第二章"},{"content":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现很多东西还是得记录一下的，脑子真的容易遗忘；二是意识到虽然自己写的很烂，但肯定会慢慢进步的，自己现在水平很低，但只要坚持学习，坚持记录，肯定会提高的。\n现在彻底决定毕业后搞开发不搞算法了，选择了 Go 语言，以前也听说过 hugo 这个生成器，就是用 Go 写的，遂决定尝试一下，还是遇到一些坑的，记录一下。\n添加搜索 因为搜索这个功能需要 index.json 这个文件，但默认是不生成的，需要在配置里打开：\n1 2 3 4 5 6  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON   另外，在生成的时候要加 -D 参数才可以，要不然不生成 /search这个路径对应的文件夹，访问的话会是 404 页面。官网查了一下这个参数的作用：\n1  -D, --buildDrafts include content marked as draft   看不太懂。。\n添加分类和标签 增加归档和搜索页面只需要创建 archives.md 和 search.md 这两个文件就行了，本来我还以为分类和标签也是这样，但是怎么试都不行，后来发现在配置文件里加上这几句就行了：\n1 2 3 4  taxonomies:  category: Categories  tag: Tags  series: series   上面这两个就是我碰见的耗时最多去解决的问题了，感觉 hugo 相关的内容在网上还不是很多，分享一下我的配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195  baseURL: \u0026#39;https://tiandiyijian.top\u0026#39; languageCode: \u0026#39;en-us\u0026#39; title: 天地一键 paginate: 10 theme: PaperMod  publishDir: docs enableInlineShortcodes: true enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true  hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启  buildDrafts: false buildFuture: false buildExpired: false  #googleAnalytics: UA-123-45 # 谷歌统计 # Copyright: Sulv  paginate: 15 # 首页每页显示的文章数  minify:  disableXML: true  # minifyOutput: true  permalinks:  post: \u0026#34;/:title/\u0026#34;  # post: \u0026#34;/:year/:month/:day/:title/\u0026#34;  params:  env: production # to enable google analytics, opengraph, twitter-cards and schema.  title: ExampleSite  description: \u0026#34;ExampleSite description\u0026#34;  keywords: [Blog, Portfolio, PaperMod]  author: Me  # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors  # images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;]  DateFormat: \u0026#34;January 2, 2006\u0026#34;  defaultTheme: auto # dark, light  disableThemeToggle: false   ShowReadingTime: true  ShowShareButtons: true  ShowPostNavLinks: true  ShowBreadCrumbs: true  ShowCodeCopyButtons: false  disableSpecial1stPost: false  disableScrollToTop: false  comments: false  hidemeta: false  hideSummary: false  showtoc: false  tocopen: false   assets:  # disableHLJS: true # to disable highlight.js  # disableFingerprinting: true  favicon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon16x16: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  favicon32x32: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  apple_touch_icon: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;  safari_pinned_tab: \u0026#34;https://s2.loli.net/2022/04/05/vc3QdeULpWlCjbh.png\u0026#34;   # profile-mode  profileMode:  enabled: false # needs to be explicitly set  title: Haha  subtitle: \u0026#34;This is subtitle\u0026#34;  imageUrl: \u0026#34;#\u0026#34;  imageWidth: 120  imageHeight: 120  imageTitle: my image  buttons:  - name: Posts  url: posts  - name: Tags  url: tags   # home-info mode  homeInfoParams:  Title: \u0026#34;Hi there \\U0001F44B\u0026#34;  Content: Welcome to my blog   socialIcons:  - name: github  url: \u0026#34;https://github.com/tiandiyijian\u0026#34;   analytics:  google:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  bing:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;  yandex:  SiteVerificationTag: \u0026#34;XYZabc\u0026#34;   cover:  hidden: true # hide everywhere but not in structured data  hiddenInList: true # hide on list pages and home  hiddenInSingle: true # hide on single page   editPost:  URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34;  Text: \u0026#34;Suggest Changes\u0026#34; # edit text  appendFilePath: true # to append file path to Edit link   # for search  # https://fusejs.io/api/options.html  fuseOpts:  isCaseSensitive: false  shouldSort: true  location: 0  distance: 1000  threshold: 0.4  minMatchCharLength: 0  keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;]   menu:  main:  - identifier: search  name: Search  url: /search/  weight: 5  - identifier: categories  name: Categories  url: /categories/  weight: 10  - identifier: tags  name: Tags  url: /tags/  weight: 20  - identifier: archives  name: Archive  url: /archives/  weight: 30   taxonomies:  category: Categories  tag: Tags  series: series  outputs:  home:  # 这个东西也太坑了，不加这个东西貌似不会生成index.json这个文件，导致搜索功能用不了  - HTML  - RSS  - JSON  markup:  goldmark:  renderer:  unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话  highlight:  # anchorLineNos: true  codeFences: true  guessSyntax: true  lineNos: true  # noClasses: false  # style: monokai  style: darcula   codeFences: true # 代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。  # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。  # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。  # lineNoStart：行号从编号几开始，一般从 1 开始。  # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true.  # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true.  # noClasses：使用 class 标签，而不是内嵌的内联样式  privacy:  vimeo:  disabled: false  simple: true   twitter:  disabled: false  enableDNT: true  simple: true   instagram:  disabled: false  simple: true   youtube:  disabled: false  privacyEnhanced: true  services:  instagram:  disableInlineCSS: true  twitter:  disableInlineCSS: true    我也还没全部搞懂上面的配置项都是啥意思，以后用的到时候再慢慢研究吧。有一说一，hugo 的速度好快啊。\n参考：\n【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://tiandiyijian.top/posts/hugo%E8%B8%A9%E5%9D%91/","summary":"最近买了个腾讯云的服务器，又想起来我还有个博客了，看了下上篇博客的日期，竟然还是20年的，有点汗颜，又决定重新开始写博客记录一下了，一是发现","title":"Hugo踩坑"}]